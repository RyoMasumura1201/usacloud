// Copyright 2017-2020 The Usacloud Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"text/template"

	"github.com/sacloud/usacloud/pkg/schema"
	"github.com/sacloud/usacloud/tools"
)

var (
	destination = "src/github.com/sacloud/usacloud/pkg/funcs"
	ctx         = tools.NewGenerateContext()
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\tgen-command-funcs\n")
	os.Exit(2)
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("gen-command-funcs: ")

	for _, r := range ctx.Resources {
		err := generateResource(r)
		if err != nil {
			log.Fatalf("writing output: %s", err)
		}
	}
}

func generateResource(resource *tools.Resource) error {

	dirName := filepath.Join(ctx.Gopath(), destination, resource.PackageDirName())
	os.MkdirAll(dirName, 0755) // nolint

	// build commands
	for _, c := range resource.Commands {
		src, err := generateCommands(c)

		if err != nil {
			return err
		}

		// Write to file.
		// like 'switch_command_list.go'
		baseName := c.CommandFileName()
		outputName := filepath.Join(ctx.Gopath(), destination, resource.PackageDirName(), baseName)

		// target file is exist?
		_, err = os.Stat(outputName)
		if !c.UseCustomCommand || err != nil {
			err = ioutil.WriteFile(outputName, tools.Sformat([]byte(src)), 0644)
			if err != nil {
				return err
			}
			fmt.Printf("generated: %s\n", filepath.Join(destination, resource.PackageDirName(), baseName))
		}
	}

	return nil
}

func generateCommands(command *tools.Command) (string, error) {
	b := bytes.NewBufferString("")
	t := template.New("c")
	template.Must(t.Parse(commandTemplate))

	action, err := generateAction(command)
	if err != nil {
		return "", err
	}

	err = t.Execute(b, map[string]interface{}{
		"FunctionName":       command.FunctionName(),
		"InputModelTypeName": command.InputModelTypeName(),
		"Action":             action,
		"UseCustomCommand":   command.UseCustomCommand,
		"PackageDirName":     command.Resource.PackageDirName(),
	})

	return b.String(), err
}

var commandTemplate = `{{ if not .UseCustomCommand}}// Code generated by 'github.com/sacloud/usacloud/tools/gen-command-funcs'; DO NOT EDIT{{ end }}

package {{ .PackageDirName }}

import (
    "fmt"

    "github.com/sacloud/libsacloud/v2/sacloud"
    "github.com/sacloud/usacloud/pkg/cli"
    "github.com/sacloud/usacloud/pkg/params"
    "github.com/sacloud/usacloud/pkg/search"
    "github.com/sacloud/usacloud/pkg/util"
)

func {{.FunctionName}}(ctx cli.Context, params *params.{{.InputModelTypeName}}) error {
    {{- .Action -}}
}
`

func generateAction(command *tools.Command) (string, error) {

	var res string
	var err error
	switch command.Type {
	case schema.CommandList:
		// list / find / search
		res, err = GenerateFindCommand(ctx, command)
	case schema.CommandCreate:
		// create
		res, err = GenerateCreateCommand(ctx, command)
	case schema.CommandRead:
		// read
		res, err = GenerateReadCommand(ctx, command)
	case schema.CommandUpdate:
		// update
		res, err = GenerateUpdateCommand(ctx, command)
	case schema.CommandDelete:
		// delete
		res, err = GenerateDeleteCommand(ctx, command)
	case schema.CommandManipulateMulti, schema.CommandManipulateSingle, schema.CommandManipulateIDOnly:
		// power-on/off
		res, err = GenerateManipulateCommand(ctx, command)
	case schema.CommandCustom:
		// custom
		res = `return fmt.Errorf("Not implements")`
	}

	return res, err
}
