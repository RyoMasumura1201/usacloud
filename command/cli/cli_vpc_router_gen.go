// Code generated by 'github.com/sacloud/usacloud/tools/gen-cli-commands'; DO NOT EDIT

package cli

import (
	"encoding/json"
	"fmt"
	"strings"
	"sync"

	"github.com/imdario/mergo"
	"github.com/sacloud/usacloud/command"
	"github.com/sacloud/usacloud/command/completion"
	"github.com/sacloud/usacloud/command/funcs"
	"github.com/sacloud/usacloud/command/params"
	"github.com/sacloud/usacloud/schema"
	"gopkg.in/urfave/cli.v2"
)

func init() {
	listParam := params.NewListVPCRouterParam()
	createParam := params.NewCreateVPCRouterParam()
	readParam := params.NewReadVPCRouterParam()
	updateParam := params.NewUpdateVPCRouterParam()
	deleteParam := params.NewDeleteVPCRouterParam()
	bootParam := params.NewBootVPCRouterParam()
	shutdownParam := params.NewShutdownVPCRouterParam()
	shutdownForceParam := params.NewShutdownForceVPCRouterParam()
	resetParam := params.NewResetVPCRouterParam()
	waitForBootParam := params.NewWaitForBootVPCRouterParam()
	waitForDownParam := params.NewWaitForDownVPCRouterParam()
	enableInternetConnectionParam := params.NewEnableInternetConnectionVPCRouterParam()
	disableInternetConnectionParam := params.NewDisableInternetConnectionVPCRouterParam()
	interfaceInfoParam := params.NewInterfaceInfoVPCRouterParam()
	interfaceConnectParam := params.NewInterfaceConnectVPCRouterParam()
	interfaceUpdateParam := params.NewInterfaceUpdateVPCRouterParam()
	interfaceDisconnectParam := params.NewInterfaceDisconnectVPCRouterParam()
	staticNatInfoParam := params.NewStaticNatInfoVPCRouterParam()
	staticNatAddParam := params.NewStaticNatAddVPCRouterParam()
	staticNatUpdateParam := params.NewStaticNatUpdateVPCRouterParam()
	staticNatDeleteParam := params.NewStaticNatDeleteVPCRouterParam()
	portForwardingInfoParam := params.NewPortForwardingInfoVPCRouterParam()
	portForwardingAddParam := params.NewPortForwardingAddVPCRouterParam()
	portForwardingUpdateParam := params.NewPortForwardingUpdateVPCRouterParam()
	portForwardingDeleteParam := params.NewPortForwardingDeleteVPCRouterParam()
	firewallInfoParam := params.NewFirewallInfoVPCRouterParam()
	firewallAddParam := params.NewFirewallAddVPCRouterParam()
	firewallUpdateParam := params.NewFirewallUpdateVPCRouterParam()
	firewallDeleteParam := params.NewFirewallDeleteVPCRouterParam()
	dhcpServerInfoParam := params.NewDhcpServerInfoVPCRouterParam()
	dhcpServerAddParam := params.NewDhcpServerAddVPCRouterParam()
	dhcpServerUpdateParam := params.NewDhcpServerUpdateVPCRouterParam()
	dhcpServerDeleteParam := params.NewDhcpServerDeleteVPCRouterParam()
	dhcpStaticMappingInfoParam := params.NewDhcpStaticMappingInfoVPCRouterParam()
	dhcpStaticMappingAddParam := params.NewDhcpStaticMappingAddVPCRouterParam()
	dhcpStaticMappingUpdateParam := params.NewDhcpStaticMappingUpdateVPCRouterParam()
	dhcpStaticMappingDeleteParam := params.NewDhcpStaticMappingDeleteVPCRouterParam()
	pptpServerInfoParam := params.NewPptpServerInfoVPCRouterParam()
	pptpServerUpdateParam := params.NewPptpServerUpdateVPCRouterParam()
	l2tpServerInfoParam := params.NewL2tpServerInfoVPCRouterParam()
	l2tpServerUpdateParam := params.NewL2tpServerUpdateVPCRouterParam()
	userInfoParam := params.NewUserInfoVPCRouterParam()
	userAddParam := params.NewUserAddVPCRouterParam()
	userUpdateParam := params.NewUserUpdateVPCRouterParam()
	userDeleteParam := params.NewUserDeleteVPCRouterParam()
	siteToSiteVpnInfoParam := params.NewSiteToSiteVpnInfoVPCRouterParam()
	siteToSiteVpnAddParam := params.NewSiteToSiteVpnAddVPCRouterParam()
	siteToSiteVpnUpdateParam := params.NewSiteToSiteVpnUpdateVPCRouterParam()
	siteToSiteVpnDeleteParam := params.NewSiteToSiteVpnDeleteVPCRouterParam()
	siteToSiteVpnPeersParam := params.NewSiteToSiteVpnPeersVPCRouterParam()
	staticRouteInfoParam := params.NewStaticRouteInfoVPCRouterParam()
	staticRouteAddParam := params.NewStaticRouteAddVPCRouterParam()
	staticRouteUpdateParam := params.NewStaticRouteUpdateVPCRouterParam()
	staticRouteDeleteParam := params.NewStaticRouteDeleteVPCRouterParam()
	monitorParam := params.NewMonitorVPCRouterParam()
	logsParam := params.NewLogsVPCRouterParam()

	cliCommand := &cli.Command{
		Name:  "vpc-router",
		Usage: "A manage commands of VPCRouter",
		Subcommands: []*cli.Command{
			{
				Name:    "list",
				Aliases: []string{"ls", "find", "selector"},
				Usage:   "List VPCRouter",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "name",
						Usage: "set filter by name(s)",
					},
					&cli.Int64SliceFlag{
						Name:  "id",
						Usage: "set filter by id(s)",
					},
					&cli.StringSliceFlag{
						Name:    "tags",
						Aliases: []string{"selector"},
						Usage:   "set filter by tags(AND)",
					},
					&cli.IntFlag{
						Name:    "from",
						Aliases: []string{"offset"},
						Usage:   "set offset",
					},
					&cli.IntFlag{
						Name:    "max",
						Aliases: []string{"limit"},
						Usage:   "set limit",
					},
					&cli.StringSliceFlag{
						Name:  "sort",
						Usage: "set field(s) for sort",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = listParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, listParam)

					// Set option values
					if c.IsSet("name") {
						listParam.Name = c.StringSlice("name")
					}
					if c.IsSet("id") {
						listParam.Id = c.Int64Slice("id")
					}
					if c.IsSet("tags") {
						listParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("from") {
						listParam.From = c.Int("from")
					}
					if c.IsSet("max") {
						listParam.Max = c.Int("max")
					}
					if c.IsSet("sort") {
						listParam.Sort = c.StringSlice("sort")
					}
					if c.IsSet("param-template") {
						listParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						listParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						listParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						listParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						listParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						listParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						listParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						listParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						listParam.Query = c.String("query")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterListCompleteArgs(ctx, listParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterListCompleteArgs(ctx, listParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterListCompleteFlags(ctx, listParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterListCompleteArgs(ctx, listParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					listParam.ParamTemplate = c.String("param-template")
					listParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(listParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewListVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(listParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("name") {
						listParam.Name = c.StringSlice("name")
					}
					if c.IsSet("id") {
						listParam.Id = c.Int64Slice("id")
					}
					if c.IsSet("tags") {
						listParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("from") {
						listParam.From = c.Int("from")
					}
					if c.IsSet("max") {
						listParam.Max = c.Int("max")
					}
					if c.IsSet("sort") {
						listParam.Sort = c.StringSlice("sort")
					}
					if c.IsSet("param-template") {
						listParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						listParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						listParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						listParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						listParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						listParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						listParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						listParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						listParam.Query = c.String("query")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = listParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if listParam.GenerateSkeleton {
						listParam.GenerateSkeleton = false
						listParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(listParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := listParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), listParam)

					// Run command with params
					return funcs.VPCRouterList(ctx, listParam)

				},
			},
			{
				Name:  "create",
				Usage: "Create VPCRouter",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "plan",
						Usage: "[Required] set plan[standard/premium/highspec]",
						Value: "standard",
					},
					&cli.Int64Flag{
						Name:  "switch-id",
						Usage: "set connect switch ID",
					},
					&cli.IntFlag{
						Name:    "vrid",
						Aliases: []string{"VRID"},
						Usage:   "[Required] set VRID",
						Value:   1,
					},
					&cli.StringFlag{
						Name:  "vip",
						Usage: "set virtual ipddress()",
					},
					&cli.StringFlag{
						Name:    "ipaddress1",
						Aliases: []string{"ip1"},
						Usage:   "set ipaddress(#1)",
					},
					&cli.StringFlag{
						Name:    "ipaddress2",
						Aliases: []string{"ip2"},
						Usage:   "set ipaddress(#2)",
					},
					&cli.BoolFlag{
						Name:  "disable-internet-connection",
						Usage: "disable internet connection from VPCRouter",
						Value: false,
					},
					&cli.BoolFlag{
						Name:  "boot-after-create",
						Usage: "boot after create",
					},
					&cli.StringFlag{
						Name:  "name",
						Usage: "[Required] set resource display name",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set resource description",
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:  "icon-id",
						Usage: "set Icon ID",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = createParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, createParam)

					// Set option values
					if c.IsSet("plan") {
						createParam.Plan = c.String("plan")
					}
					if c.IsSet("switch-id") {
						createParam.SwitchId = c.Int64("switch-id")
					}
					if c.IsSet("vrid") {
						createParam.Vrid = c.Int("vrid")
					}
					if c.IsSet("vip") {
						createParam.Vip = c.String("vip")
					}
					if c.IsSet("ipaddress1") {
						createParam.Ipaddress1 = c.String("ipaddress1")
					}
					if c.IsSet("ipaddress2") {
						createParam.Ipaddress2 = c.String("ipaddress2")
					}
					if c.IsSet("disable-internet-connection") {
						createParam.DisableInternetConnection = c.Bool("disable-internet-connection")
					}
					if c.IsSet("boot-after-create") {
						createParam.BootAfterCreate = c.Bool("boot-after-create")
					}
					if c.IsSet("name") {
						createParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						createParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						createParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						createParam.IconId = c.Int64("icon-id")
					}
					if c.IsSet("assumeyes") {
						createParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						createParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						createParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						createParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						createParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						createParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						createParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						createParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						createParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						createParam.Query = c.String("query")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterCreateCompleteArgs(ctx, createParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterCreateCompleteArgs(ctx, createParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterCreateCompleteFlags(ctx, createParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterCreateCompleteArgs(ctx, createParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					createParam.ParamTemplate = c.String("param-template")
					createParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(createParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewCreateVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(createParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("plan") {
						createParam.Plan = c.String("plan")
					}
					if c.IsSet("switch-id") {
						createParam.SwitchId = c.Int64("switch-id")
					}
					if c.IsSet("vrid") {
						createParam.Vrid = c.Int("vrid")
					}
					if c.IsSet("vip") {
						createParam.Vip = c.String("vip")
					}
					if c.IsSet("ipaddress1") {
						createParam.Ipaddress1 = c.String("ipaddress1")
					}
					if c.IsSet("ipaddress2") {
						createParam.Ipaddress2 = c.String("ipaddress2")
					}
					if c.IsSet("disable-internet-connection") {
						createParam.DisableInternetConnection = c.Bool("disable-internet-connection")
					}
					if c.IsSet("boot-after-create") {
						createParam.BootAfterCreate = c.Bool("boot-after-create")
					}
					if c.IsSet("name") {
						createParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						createParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						createParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						createParam.IconId = c.Int64("icon-id")
					}
					if c.IsSet("assumeyes") {
						createParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						createParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						createParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						createParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						createParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						createParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						createParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						createParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						createParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						createParam.Query = c.String("query")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = createParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if createParam.GenerateSkeleton {
						createParam.GenerateSkeleton = false
						createParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(createParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := createParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), createParam)

					// confirm
					if !createParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("create") {
							return nil
						}
					}

					// Run command with params
					return funcs.VPCRouterCreate(ctx, createParam)

				},
			},
			{
				Name:      "read",
				Usage:     "Read VPCRouter",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = readParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, readParam)

					// Set option values
					if c.IsSet("selector") {
						readParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						readParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						readParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						readParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						readParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						readParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						readParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						readParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						readParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						readParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						readParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterReadCompleteArgs(ctx, readParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterReadCompleteArgs(ctx, readParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterReadCompleteFlags(ctx, readParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterReadCompleteArgs(ctx, readParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					readParam.ParamTemplate = c.String("param-template")
					readParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(readParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewReadVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(readParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						readParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						readParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						readParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						readParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						readParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						readParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						readParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						readParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						readParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						readParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						readParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = readParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if readParam.GenerateSkeleton {
						readParam.GenerateSkeleton = false
						readParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(readParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := readParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), readParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(readParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, readParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", readParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(readParam.Selector) == 0 || hasTags(&v, readParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						readParam.SetId(id)
						p := *readParam // copy struct value
						readParam := &p
						go func() {
							err := funcs.VPCRouterRead(ctx, readParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "update",
				Usage:     "Update VPCRouter",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "syslog-host",
						Usage: "set syslog host IPAddress",
					},
					&cli.BoolFlag{
						Name:  "internet-connection",
						Usage: "set internet connection from VPCRouter",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "name",
						Usage: "set resource display name",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set resource description",
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:  "icon-id",
						Usage: "set Icon ID",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = updateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, updateParam)

					// Set option values
					if c.IsSet("syslog-host") {
						updateParam.SyslogHost = c.String("syslog-host")
					}
					if c.IsSet("internet-connection") {
						updateParam.InternetConnection = c.Bool("internet-connection")
					}
					if c.IsSet("selector") {
						updateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("name") {
						updateParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						updateParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						updateParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						updateParam.IconId = c.Int64("icon-id")
					}
					if c.IsSet("assumeyes") {
						updateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						updateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						updateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						updateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						updateParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						updateParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						updateParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						updateParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						updateParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						updateParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						updateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterUpdateCompleteFlags(ctx, updateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					updateParam.ParamTemplate = c.String("param-template")
					updateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(updateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewUpdateVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(updateParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("syslog-host") {
						updateParam.SyslogHost = c.String("syslog-host")
					}
					if c.IsSet("internet-connection") {
						updateParam.InternetConnection = c.Bool("internet-connection")
					}
					if c.IsSet("selector") {
						updateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("name") {
						updateParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						updateParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						updateParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						updateParam.IconId = c.Int64("icon-id")
					}
					if c.IsSet("assumeyes") {
						updateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						updateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						updateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						updateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						updateParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						updateParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						updateParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						updateParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						updateParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						updateParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						updateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = updateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if updateParam.GenerateSkeleton {
						updateParam.GenerateSkeleton = false
						updateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(updateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := updateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), updateParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(updateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, updateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", updateParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(updateParam.Selector) == 0 || hasTags(&v, updateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !updateParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("update", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						updateParam.SetId(id)
						p := *updateParam // copy struct value
						updateParam := &p
						go func() {
							err := funcs.VPCRouterUpdate(ctx, updateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "delete",
				Aliases:   []string{"rm"},
				Usage:     "Delete VPCRouter",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:    "force",
						Aliases: []string{"f"},
						Usage:   "forced-shutdown flag if server is running",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = deleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, deleteParam)

					// Set option values
					if c.IsSet("force") {
						deleteParam.Force = c.Bool("force")
					}
					if c.IsSet("selector") {
						deleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						deleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						deleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						deleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						deleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						deleteParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						deleteParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						deleteParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						deleteParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						deleteParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						deleteParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						deleteParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDeleteCompleteFlags(ctx, deleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					deleteParam.ParamTemplate = c.String("param-template")
					deleteParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(deleteParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDeleteVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(deleteParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("force") {
						deleteParam.Force = c.Bool("force")
					}
					if c.IsSet("selector") {
						deleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						deleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						deleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						deleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						deleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						deleteParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						deleteParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						deleteParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						deleteParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						deleteParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						deleteParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						deleteParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = deleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if deleteParam.GenerateSkeleton {
						deleteParam.GenerateSkeleton = false
						deleteParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(deleteParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := deleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), deleteParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(deleteParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, deleteParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", deleteParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(deleteParam.Selector) == 0 || hasTags(&v, deleteParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !deleteParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("delete", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						deleteParam.SetId(id)
						p := *deleteParam // copy struct value
						deleteParam := &p
						go func() {
							err := funcs.VPCRouterDelete(ctx, deleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "boot",
				Aliases:   []string{"power-on"},
				Usage:     "Boot VPCRouter",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = bootParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, bootParam)

					// Set option values
					if c.IsSet("selector") {
						bootParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						bootParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						bootParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						bootParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						bootParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						bootParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterBootCompleteFlags(ctx, bootParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					bootParam.ParamTemplate = c.String("param-template")
					bootParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(bootParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewBootVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(bootParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						bootParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						bootParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						bootParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						bootParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						bootParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						bootParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = bootParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if bootParam.GenerateSkeleton {
						bootParam.GenerateSkeleton = false
						bootParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(bootParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := bootParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), bootParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(bootParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, bootParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", bootParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(bootParam.Selector) == 0 || hasTags(&v, bootParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !bootParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("boot", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						bootParam.SetId(id)
						p := *bootParam // copy struct value
						bootParam := &p
						go func() {
							err := funcs.VPCRouterBoot(ctx, bootParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "shutdown",
				Aliases:   []string{"power-off"},
				Usage:     "Shutdown VPCRouter",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = shutdownParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, shutdownParam)

					// Set option values
					if c.IsSet("selector") {
						shutdownParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						shutdownParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						shutdownParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						shutdownParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						shutdownParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						shutdownParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterShutdownCompleteFlags(ctx, shutdownParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					shutdownParam.ParamTemplate = c.String("param-template")
					shutdownParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(shutdownParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewShutdownVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(shutdownParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						shutdownParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						shutdownParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						shutdownParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						shutdownParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						shutdownParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						shutdownParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = shutdownParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if shutdownParam.GenerateSkeleton {
						shutdownParam.GenerateSkeleton = false
						shutdownParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(shutdownParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := shutdownParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), shutdownParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(shutdownParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, shutdownParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", shutdownParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(shutdownParam.Selector) == 0 || hasTags(&v, shutdownParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !shutdownParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("shutdown", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						shutdownParam.SetId(id)
						p := *shutdownParam // copy struct value
						shutdownParam := &p
						go func() {
							err := funcs.VPCRouterShutdown(ctx, shutdownParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "shutdown-force",
				Aliases:   []string{"stop"},
				Usage:     "ShutdownForce VPCRouter",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = shutdownForceParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, shutdownForceParam)

					// Set option values
					if c.IsSet("selector") {
						shutdownForceParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						shutdownForceParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						shutdownForceParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						shutdownForceParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						shutdownForceParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						shutdownForceParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterShutdownForceCompleteFlags(ctx, shutdownForceParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					shutdownForceParam.ParamTemplate = c.String("param-template")
					shutdownForceParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(shutdownForceParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewShutdownForceVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(shutdownForceParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						shutdownForceParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						shutdownForceParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						shutdownForceParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						shutdownForceParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						shutdownForceParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						shutdownForceParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = shutdownForceParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if shutdownForceParam.GenerateSkeleton {
						shutdownForceParam.GenerateSkeleton = false
						shutdownForceParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(shutdownForceParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := shutdownForceParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), shutdownForceParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(shutdownForceParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, shutdownForceParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", shutdownForceParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(shutdownForceParam.Selector) == 0 || hasTags(&v, shutdownForceParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !shutdownForceParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("shutdown-force", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						shutdownForceParam.SetId(id)
						p := *shutdownForceParam // copy struct value
						shutdownForceParam := &p
						go func() {
							err := funcs.VPCRouterShutdownForce(ctx, shutdownForceParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "reset",
				Usage:     "Reset VPCRouter",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = resetParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, resetParam)

					// Set option values
					if c.IsSet("selector") {
						resetParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						resetParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						resetParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						resetParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						resetParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						resetParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterResetCompleteFlags(ctx, resetParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					resetParam.ParamTemplate = c.String("param-template")
					resetParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(resetParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewResetVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(resetParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						resetParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						resetParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						resetParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						resetParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						resetParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						resetParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = resetParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if resetParam.GenerateSkeleton {
						resetParam.GenerateSkeleton = false
						resetParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(resetParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := resetParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), resetParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(resetParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, resetParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", resetParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(resetParam.Selector) == 0 || hasTags(&v, resetParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !resetParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("reset", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						resetParam.SetId(id)
						p := *resetParam // copy struct value
						resetParam := &p
						go func() {
							err := funcs.VPCRouterReset(ctx, resetParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "wait-for-boot",
				Usage:     "Wait until boot is completed",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = waitForBootParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, waitForBootParam)

					// Set option values
					if c.IsSet("selector") {
						waitForBootParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						waitForBootParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						waitForBootParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						waitForBootParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						waitForBootParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterWaitForBootCompleteFlags(ctx, waitForBootParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					waitForBootParam.ParamTemplate = c.String("param-template")
					waitForBootParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(waitForBootParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewWaitForBootVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(waitForBootParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						waitForBootParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						waitForBootParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						waitForBootParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						waitForBootParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						waitForBootParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = waitForBootParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if waitForBootParam.GenerateSkeleton {
						waitForBootParam.GenerateSkeleton = false
						waitForBootParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(waitForBootParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := waitForBootParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), waitForBootParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(waitForBootParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, waitForBootParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", waitForBootParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(waitForBootParam.Selector) == 0 || hasTags(&v, waitForBootParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						waitForBootParam.SetId(id)
						p := *waitForBootParam // copy struct value
						waitForBootParam := &p
						go func() {
							err := funcs.VPCRouterWaitForBoot(ctx, waitForBootParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "wait-for-down",
				Usage:     "Wait until shutdown is completed",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = waitForDownParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, waitForDownParam)

					// Set option values
					if c.IsSet("selector") {
						waitForDownParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						waitForDownParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						waitForDownParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						waitForDownParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						waitForDownParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterWaitForDownCompleteFlags(ctx, waitForDownParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					waitForDownParam.ParamTemplate = c.String("param-template")
					waitForDownParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(waitForDownParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewWaitForDownVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(waitForDownParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						waitForDownParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						waitForDownParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						waitForDownParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						waitForDownParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						waitForDownParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = waitForDownParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if waitForDownParam.GenerateSkeleton {
						waitForDownParam.GenerateSkeleton = false
						waitForDownParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(waitForDownParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := waitForDownParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), waitForDownParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(waitForDownParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, waitForDownParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", waitForDownParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(waitForDownParam.Selector) == 0 || hasTags(&v, waitForDownParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						waitForDownParam.SetId(id)
						p := *waitForDownParam // copy struct value
						waitForDownParam := &p
						go func() {
							err := funcs.VPCRouterWaitForDown(ctx, waitForDownParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "enable-internet-connection",
				Usage:     "Enable internet connection from VPCRouter",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = enableInternetConnectionParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, enableInternetConnectionParam)

					// Set option values
					if c.IsSet("selector") {
						enableInternetConnectionParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						enableInternetConnectionParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						enableInternetConnectionParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						enableInternetConnectionParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						enableInternetConnectionParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						enableInternetConnectionParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterEnableInternetConnectionCompleteArgs(ctx, enableInternetConnectionParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterEnableInternetConnectionCompleteArgs(ctx, enableInternetConnectionParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterEnableInternetConnectionCompleteFlags(ctx, enableInternetConnectionParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterEnableInternetConnectionCompleteArgs(ctx, enableInternetConnectionParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					enableInternetConnectionParam.ParamTemplate = c.String("param-template")
					enableInternetConnectionParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(enableInternetConnectionParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewEnableInternetConnectionVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(enableInternetConnectionParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						enableInternetConnectionParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						enableInternetConnectionParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						enableInternetConnectionParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						enableInternetConnectionParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						enableInternetConnectionParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						enableInternetConnectionParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = enableInternetConnectionParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if enableInternetConnectionParam.GenerateSkeleton {
						enableInternetConnectionParam.GenerateSkeleton = false
						enableInternetConnectionParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(enableInternetConnectionParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := enableInternetConnectionParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), enableInternetConnectionParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(enableInternetConnectionParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, enableInternetConnectionParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", enableInternetConnectionParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(enableInternetConnectionParam.Selector) == 0 || hasTags(&v, enableInternetConnectionParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !enableInternetConnectionParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("enable-internet-connection", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						enableInternetConnectionParam.SetId(id)
						p := *enableInternetConnectionParam // copy struct value
						enableInternetConnectionParam := &p
						go func() {
							err := funcs.VPCRouterEnableInternetConnection(ctx, enableInternetConnectionParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "disable-internet-connection",
				Usage:     "Enable internet connection from VPCRouter",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = disableInternetConnectionParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, disableInternetConnectionParam)

					// Set option values
					if c.IsSet("selector") {
						disableInternetConnectionParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						disableInternetConnectionParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						disableInternetConnectionParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						disableInternetConnectionParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						disableInternetConnectionParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						disableInternetConnectionParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDisableInternetConnectionCompleteArgs(ctx, disableInternetConnectionParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDisableInternetConnectionCompleteArgs(ctx, disableInternetConnectionParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDisableInternetConnectionCompleteFlags(ctx, disableInternetConnectionParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDisableInternetConnectionCompleteArgs(ctx, disableInternetConnectionParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					disableInternetConnectionParam.ParamTemplate = c.String("param-template")
					disableInternetConnectionParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(disableInternetConnectionParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDisableInternetConnectionVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(disableInternetConnectionParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						disableInternetConnectionParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						disableInternetConnectionParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						disableInternetConnectionParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						disableInternetConnectionParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						disableInternetConnectionParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						disableInternetConnectionParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = disableInternetConnectionParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if disableInternetConnectionParam.GenerateSkeleton {
						disableInternetConnectionParam.GenerateSkeleton = false
						disableInternetConnectionParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(disableInternetConnectionParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := disableInternetConnectionParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), disableInternetConnectionParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(disableInternetConnectionParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, disableInternetConnectionParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", disableInternetConnectionParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(disableInternetConnectionParam.Selector) == 0 || hasTags(&v, disableInternetConnectionParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !disableInternetConnectionParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("disable-internet-connection", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						disableInternetConnectionParam.SetId(id)
						p := *disableInternetConnectionParam // copy struct value
						disableInternetConnectionParam := &p
						go func() {
							err := funcs.VPCRouterDisableInternetConnection(ctx, disableInternetConnectionParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-info",
				Aliases:   []string{"interface-list"},
				Usage:     "Show information of NIC(s) connected to vpc-router",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = interfaceInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceInfoParam)

					// Set option values
					if c.IsSet("selector") {
						interfaceInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						interfaceInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						interfaceInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						interfaceInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						interfaceInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						interfaceInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						interfaceInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						interfaceInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						interfaceInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterInterfaceInfoCompleteArgs(ctx, interfaceInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterInterfaceInfoCompleteArgs(ctx, interfaceInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterInterfaceInfoCompleteFlags(ctx, interfaceInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterInterfaceInfoCompleteArgs(ctx, interfaceInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					interfaceInfoParam.ParamTemplate = c.String("param-template")
					interfaceInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(interfaceInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewInterfaceInfoVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(interfaceInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						interfaceInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						interfaceInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						interfaceInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						interfaceInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						interfaceInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						interfaceInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						interfaceInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						interfaceInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						interfaceInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = interfaceInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if interfaceInfoParam.GenerateSkeleton {
						interfaceInfoParam.GenerateSkeleton = false
						interfaceInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(interfaceInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := interfaceInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceInfoParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(interfaceInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, interfaceInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", interfaceInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(interfaceInfoParam.Selector) == 0 || hasTags(&v, interfaceInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceInfoParam.SetId(id)
						p := *interfaceInfoParam // copy struct value
						interfaceInfoParam := &p
						go func() {
							err := funcs.VPCRouterInterfaceInfo(ctx, interfaceInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-connect",
				Usage:     "Connected to switch",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "interface",
						Usage: "[Required] index of target private-interface",
					},
					&cli.StringFlag{
						Name:    "ipaddress",
						Aliases: []string{"ip", "vip"},
						Usage:   "[Required] set (virtual)ipaddress",
					},
					&cli.BoolFlag{
						Name:  "with-reboot",
						Usage: "reboot after connect",
					},
					&cli.StringFlag{
						Name:    "ipaddress1",
						Aliases: []string{"ip1"},
						Usage:   "set ipaddress(#1)",
					},
					&cli.Int64Flag{
						Name:  "switch-id",
						Usage: "[Required] set connect switch ID",
					},
					&cli.StringFlag{
						Name:    "ipaddress2",
						Aliases: []string{"ip2"},
						Usage:   "set ipaddress(#2)",
					},
					&cli.IntFlag{
						Name:    "nw-masklen",
						Aliases: []string{"network-masklen"},
						Usage:   "set ipaddress prefix",
						Value:   24,
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = interfaceConnectParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceConnectParam)

					// Set option values
					if c.IsSet("interface") {
						interfaceConnectParam.Interface = c.String("interface")
					}
					if c.IsSet("ipaddress") {
						interfaceConnectParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("with-reboot") {
						interfaceConnectParam.WithReboot = c.Bool("with-reboot")
					}
					if c.IsSet("ipaddress1") {
						interfaceConnectParam.Ipaddress1 = c.String("ipaddress1")
					}
					if c.IsSet("switch-id") {
						interfaceConnectParam.SwitchId = c.Int64("switch-id")
					}
					if c.IsSet("ipaddress2") {
						interfaceConnectParam.Ipaddress2 = c.String("ipaddress2")
					}
					if c.IsSet("nw-masklen") {
						interfaceConnectParam.NwMasklen = c.Int("nw-masklen")
					}
					if c.IsSet("selector") {
						interfaceConnectParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						interfaceConnectParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						interfaceConnectParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceConnectParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceConnectParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						interfaceConnectParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterInterfaceConnectCompleteArgs(ctx, interfaceConnectParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterInterfaceConnectCompleteArgs(ctx, interfaceConnectParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterInterfaceConnectCompleteFlags(ctx, interfaceConnectParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterInterfaceConnectCompleteArgs(ctx, interfaceConnectParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					interfaceConnectParam.ParamTemplate = c.String("param-template")
					interfaceConnectParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(interfaceConnectParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewInterfaceConnectVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(interfaceConnectParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("interface") {
						interfaceConnectParam.Interface = c.String("interface")
					}
					if c.IsSet("ipaddress") {
						interfaceConnectParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("with-reboot") {
						interfaceConnectParam.WithReboot = c.Bool("with-reboot")
					}
					if c.IsSet("ipaddress1") {
						interfaceConnectParam.Ipaddress1 = c.String("ipaddress1")
					}
					if c.IsSet("switch-id") {
						interfaceConnectParam.SwitchId = c.Int64("switch-id")
					}
					if c.IsSet("ipaddress2") {
						interfaceConnectParam.Ipaddress2 = c.String("ipaddress2")
					}
					if c.IsSet("nw-masklen") {
						interfaceConnectParam.NwMasklen = c.Int("nw-masklen")
					}
					if c.IsSet("selector") {
						interfaceConnectParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						interfaceConnectParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						interfaceConnectParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceConnectParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceConnectParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						interfaceConnectParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = interfaceConnectParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if interfaceConnectParam.GenerateSkeleton {
						interfaceConnectParam.GenerateSkeleton = false
						interfaceConnectParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(interfaceConnectParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := interfaceConnectParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceConnectParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(interfaceConnectParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, interfaceConnectParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", interfaceConnectParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(interfaceConnectParam.Selector) == 0 || hasTags(&v, interfaceConnectParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !interfaceConnectParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("interface-connect", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceConnectParam.SetId(id)
						p := *interfaceConnectParam // copy struct value
						interfaceConnectParam := &p
						go func() {
							err := funcs.VPCRouterInterfaceConnect(ctx, interfaceConnectParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-update",
				Usage:     "Update interface",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "interface",
						Usage: "[Required] index of target interface",
					},
					&cli.StringFlag{
						Name:    "ipaddress",
						Aliases: []string{"ip", "vip"},
						Usage:   "set (virtual)ipaddress",
					},
					&cli.BoolFlag{
						Name:  "with-reboot",
						Usage: "reboot after connect",
					},
					&cli.StringFlag{
						Name:    "ipaddress1",
						Aliases: []string{"ip1"},
						Usage:   "set ipaddress(#1)",
					},
					&cli.Int64Flag{
						Name:  "switch-id",
						Usage: "set connect switch ID",
					},
					&cli.StringFlag{
						Name:    "ipaddress2",
						Aliases: []string{"ip2"},
						Usage:   "set ipaddress(#2)",
					},
					&cli.StringSliceFlag{
						Name:  "alias",
						Usage: "set ip aliases",
					},
					&cli.IntFlag{
						Name:    "nw-masklen",
						Aliases: []string{"network-masklen"},
						Usage:   "set ipaddress prefix",
						Value:   24,
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = interfaceUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceUpdateParam)

					// Set option values
					if c.IsSet("interface") {
						interfaceUpdateParam.Interface = c.String("interface")
					}
					if c.IsSet("ipaddress") {
						interfaceUpdateParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("with-reboot") {
						interfaceUpdateParam.WithReboot = c.Bool("with-reboot")
					}
					if c.IsSet("ipaddress1") {
						interfaceUpdateParam.Ipaddress1 = c.String("ipaddress1")
					}
					if c.IsSet("switch-id") {
						interfaceUpdateParam.SwitchId = c.Int64("switch-id")
					}
					if c.IsSet("ipaddress2") {
						interfaceUpdateParam.Ipaddress2 = c.String("ipaddress2")
					}
					if c.IsSet("alias") {
						interfaceUpdateParam.Alias = c.StringSlice("alias")
					}
					if c.IsSet("nw-masklen") {
						interfaceUpdateParam.NwMasklen = c.Int("nw-masklen")
					}
					if c.IsSet("selector") {
						interfaceUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						interfaceUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						interfaceUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						interfaceUpdateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterInterfaceUpdateCompleteArgs(ctx, interfaceUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterInterfaceUpdateCompleteArgs(ctx, interfaceUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterInterfaceUpdateCompleteFlags(ctx, interfaceUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterInterfaceUpdateCompleteArgs(ctx, interfaceUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					interfaceUpdateParam.ParamTemplate = c.String("param-template")
					interfaceUpdateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(interfaceUpdateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewInterfaceUpdateVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(interfaceUpdateParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("interface") {
						interfaceUpdateParam.Interface = c.String("interface")
					}
					if c.IsSet("ipaddress") {
						interfaceUpdateParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("with-reboot") {
						interfaceUpdateParam.WithReboot = c.Bool("with-reboot")
					}
					if c.IsSet("ipaddress1") {
						interfaceUpdateParam.Ipaddress1 = c.String("ipaddress1")
					}
					if c.IsSet("switch-id") {
						interfaceUpdateParam.SwitchId = c.Int64("switch-id")
					}
					if c.IsSet("ipaddress2") {
						interfaceUpdateParam.Ipaddress2 = c.String("ipaddress2")
					}
					if c.IsSet("alias") {
						interfaceUpdateParam.Alias = c.StringSlice("alias")
					}
					if c.IsSet("nw-masklen") {
						interfaceUpdateParam.NwMasklen = c.Int("nw-masklen")
					}
					if c.IsSet("selector") {
						interfaceUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						interfaceUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						interfaceUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						interfaceUpdateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = interfaceUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if interfaceUpdateParam.GenerateSkeleton {
						interfaceUpdateParam.GenerateSkeleton = false
						interfaceUpdateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(interfaceUpdateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := interfaceUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceUpdateParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(interfaceUpdateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, interfaceUpdateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", interfaceUpdateParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(interfaceUpdateParam.Selector) == 0 || hasTags(&v, interfaceUpdateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !interfaceUpdateParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("interface-update", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceUpdateParam.SetId(id)
						p := *interfaceUpdateParam // copy struct value
						interfaceUpdateParam := &p
						go func() {
							err := funcs.VPCRouterInterfaceUpdate(ctx, interfaceUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-disconnect",
				Usage:     "Disconnected to switch",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "interface",
						Usage: "[Required] index of target private-interface",
					},
					&cli.BoolFlag{
						Name:  "with-reboot",
						Usage: "reboot after connect",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = interfaceDisconnectParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceDisconnectParam)

					// Set option values
					if c.IsSet("interface") {
						interfaceDisconnectParam.Interface = c.String("interface")
					}
					if c.IsSet("with-reboot") {
						interfaceDisconnectParam.WithReboot = c.Bool("with-reboot")
					}
					if c.IsSet("selector") {
						interfaceDisconnectParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						interfaceDisconnectParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						interfaceDisconnectParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceDisconnectParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceDisconnectParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						interfaceDisconnectParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterInterfaceDisconnectCompleteArgs(ctx, interfaceDisconnectParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterInterfaceDisconnectCompleteArgs(ctx, interfaceDisconnectParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterInterfaceDisconnectCompleteFlags(ctx, interfaceDisconnectParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterInterfaceDisconnectCompleteArgs(ctx, interfaceDisconnectParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					interfaceDisconnectParam.ParamTemplate = c.String("param-template")
					interfaceDisconnectParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(interfaceDisconnectParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewInterfaceDisconnectVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(interfaceDisconnectParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("interface") {
						interfaceDisconnectParam.Interface = c.String("interface")
					}
					if c.IsSet("with-reboot") {
						interfaceDisconnectParam.WithReboot = c.Bool("with-reboot")
					}
					if c.IsSet("selector") {
						interfaceDisconnectParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						interfaceDisconnectParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						interfaceDisconnectParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceDisconnectParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceDisconnectParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						interfaceDisconnectParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = interfaceDisconnectParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if interfaceDisconnectParam.GenerateSkeleton {
						interfaceDisconnectParam.GenerateSkeleton = false
						interfaceDisconnectParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(interfaceDisconnectParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := interfaceDisconnectParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceDisconnectParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(interfaceDisconnectParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, interfaceDisconnectParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", interfaceDisconnectParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(interfaceDisconnectParam.Selector) == 0 || hasTags(&v, interfaceDisconnectParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !interfaceDisconnectParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("interface-disconnect", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceDisconnectParam.SetId(id)
						p := *interfaceDisconnectParam // copy struct value
						interfaceDisconnectParam := &p
						go func() {
							err := funcs.VPCRouterInterfaceDisconnect(ctx, interfaceDisconnectParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-nat-info",
				Aliases:   []string{"static-nat-list"},
				Usage:     "Show information of static NAT settings",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = staticNatInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, staticNatInfoParam)

					// Set option values
					if c.IsSet("selector") {
						staticNatInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						staticNatInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticNatInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticNatInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						staticNatInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						staticNatInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						staticNatInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						staticNatInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						staticNatInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						staticNatInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						staticNatInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticNatInfoCompleteArgs(ctx, staticNatInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticNatInfoCompleteArgs(ctx, staticNatInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticNatInfoCompleteFlags(ctx, staticNatInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticNatInfoCompleteArgs(ctx, staticNatInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					staticNatInfoParam.ParamTemplate = c.String("param-template")
					staticNatInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(staticNatInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewStaticNatInfoVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(staticNatInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						staticNatInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						staticNatInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticNatInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticNatInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						staticNatInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						staticNatInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						staticNatInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						staticNatInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						staticNatInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						staticNatInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						staticNatInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = staticNatInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if staticNatInfoParam.GenerateSkeleton {
						staticNatInfoParam.GenerateSkeleton = false
						staticNatInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(staticNatInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := staticNatInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticNatInfoParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(staticNatInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, staticNatInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", staticNatInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(staticNatInfoParam.Selector) == 0 || hasTags(&v, staticNatInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticNatInfoParam.SetId(id)
						p := *staticNatInfoParam // copy struct value
						staticNatInfoParam := &p
						go func() {
							err := funcs.VPCRouterStaticNatInfo(ctx, staticNatInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-nat-add",
				Usage:     "Add static NAT",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "global",
						Aliases: []string{"global-ip", "global-address"},
						Usage:   "[Required] set global ipaddress",
					},
					&cli.StringFlag{
						Name:    "private",
						Aliases: []string{"private-ip", "private-address"},
						Usage:   "[Required] set private ipaddress",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set description",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = staticNatAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, staticNatAddParam)

					// Set option values
					if c.IsSet("global") {
						staticNatAddParam.Global = c.String("global")
					}
					if c.IsSet("private") {
						staticNatAddParam.Private = c.String("private")
					}
					if c.IsSet("description") {
						staticNatAddParam.Description = c.String("description")
					}
					if c.IsSet("selector") {
						staticNatAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						staticNatAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						staticNatAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticNatAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticNatAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						staticNatAddParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticNatAddCompleteArgs(ctx, staticNatAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticNatAddCompleteArgs(ctx, staticNatAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticNatAddCompleteFlags(ctx, staticNatAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticNatAddCompleteArgs(ctx, staticNatAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					staticNatAddParam.ParamTemplate = c.String("param-template")
					staticNatAddParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(staticNatAddParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewStaticNatAddVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(staticNatAddParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("global") {
						staticNatAddParam.Global = c.String("global")
					}
					if c.IsSet("private") {
						staticNatAddParam.Private = c.String("private")
					}
					if c.IsSet("description") {
						staticNatAddParam.Description = c.String("description")
					}
					if c.IsSet("selector") {
						staticNatAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						staticNatAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						staticNatAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticNatAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticNatAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						staticNatAddParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = staticNatAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if staticNatAddParam.GenerateSkeleton {
						staticNatAddParam.GenerateSkeleton = false
						staticNatAddParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(staticNatAddParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := staticNatAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticNatAddParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(staticNatAddParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, staticNatAddParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", staticNatAddParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(staticNatAddParam.Selector) == 0 || hasTags(&v, staticNatAddParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !staticNatAddParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("static-nat-add", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticNatAddParam.SetId(id)
						p := *staticNatAddParam // copy struct value
						staticNatAddParam := &p
						go func() {
							err := funcs.VPCRouterStaticNatAdd(ctx, staticNatAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-nat-update",
				Usage:     "Update static NAT",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target static NAT",
					},
					&cli.StringFlag{
						Name:    "global",
						Aliases: []string{"global-ip", "global-address"},
						Usage:   "set global ipaddress",
					},
					&cli.StringFlag{
						Name:    "private",
						Aliases: []string{"private-ip", "private-address"},
						Usage:   "set private ipaddress",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set description",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = staticNatUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, staticNatUpdateParam)

					// Set option values
					if c.IsSet("index") {
						staticNatUpdateParam.Index = c.Int("index")
					}
					if c.IsSet("global") {
						staticNatUpdateParam.Global = c.String("global")
					}
					if c.IsSet("private") {
						staticNatUpdateParam.Private = c.String("private")
					}
					if c.IsSet("description") {
						staticNatUpdateParam.Description = c.String("description")
					}
					if c.IsSet("selector") {
						staticNatUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						staticNatUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						staticNatUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticNatUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticNatUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						staticNatUpdateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticNatUpdateCompleteArgs(ctx, staticNatUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticNatUpdateCompleteArgs(ctx, staticNatUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticNatUpdateCompleteFlags(ctx, staticNatUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticNatUpdateCompleteArgs(ctx, staticNatUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					staticNatUpdateParam.ParamTemplate = c.String("param-template")
					staticNatUpdateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(staticNatUpdateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewStaticNatUpdateVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(staticNatUpdateParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("index") {
						staticNatUpdateParam.Index = c.Int("index")
					}
					if c.IsSet("global") {
						staticNatUpdateParam.Global = c.String("global")
					}
					if c.IsSet("private") {
						staticNatUpdateParam.Private = c.String("private")
					}
					if c.IsSet("description") {
						staticNatUpdateParam.Description = c.String("description")
					}
					if c.IsSet("selector") {
						staticNatUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						staticNatUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						staticNatUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticNatUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticNatUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						staticNatUpdateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = staticNatUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if staticNatUpdateParam.GenerateSkeleton {
						staticNatUpdateParam.GenerateSkeleton = false
						staticNatUpdateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(staticNatUpdateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := staticNatUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticNatUpdateParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(staticNatUpdateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, staticNatUpdateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", staticNatUpdateParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(staticNatUpdateParam.Selector) == 0 || hasTags(&v, staticNatUpdateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !staticNatUpdateParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("static-nat-update", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticNatUpdateParam.SetId(id)
						p := *staticNatUpdateParam // copy struct value
						staticNatUpdateParam := &p
						go func() {
							err := funcs.VPCRouterStaticNatUpdate(ctx, staticNatUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-nat-delete",
				Usage:     "Delete static NAT",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target static NAT",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = staticNatDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, staticNatDeleteParam)

					// Set option values
					if c.IsSet("index") {
						staticNatDeleteParam.Index = c.Int("index")
					}
					if c.IsSet("selector") {
						staticNatDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						staticNatDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						staticNatDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticNatDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticNatDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						staticNatDeleteParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticNatDeleteCompleteArgs(ctx, staticNatDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticNatDeleteCompleteArgs(ctx, staticNatDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticNatDeleteCompleteFlags(ctx, staticNatDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticNatDeleteCompleteArgs(ctx, staticNatDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					staticNatDeleteParam.ParamTemplate = c.String("param-template")
					staticNatDeleteParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(staticNatDeleteParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewStaticNatDeleteVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(staticNatDeleteParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("index") {
						staticNatDeleteParam.Index = c.Int("index")
					}
					if c.IsSet("selector") {
						staticNatDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						staticNatDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						staticNatDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticNatDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticNatDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						staticNatDeleteParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = staticNatDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if staticNatDeleteParam.GenerateSkeleton {
						staticNatDeleteParam.GenerateSkeleton = false
						staticNatDeleteParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(staticNatDeleteParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := staticNatDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticNatDeleteParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(staticNatDeleteParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, staticNatDeleteParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", staticNatDeleteParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(staticNatDeleteParam.Selector) == 0 || hasTags(&v, staticNatDeleteParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !staticNatDeleteParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("static-nat-delete", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticNatDeleteParam.SetId(id)
						p := *staticNatDeleteParam // copy struct value
						staticNatDeleteParam := &p
						go func() {
							err := funcs.VPCRouterStaticNatDelete(ctx, staticNatDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "port-forwarding-info",
				Aliases:   []string{"port-forwarding-list"},
				Usage:     "Show information of port-forwarding settings",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = portForwardingInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, portForwardingInfoParam)

					// Set option values
					if c.IsSet("selector") {
						portForwardingInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						portForwardingInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						portForwardingInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						portForwardingInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						portForwardingInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						portForwardingInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						portForwardingInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						portForwardingInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						portForwardingInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						portForwardingInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						portForwardingInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterPortForwardingInfoCompleteArgs(ctx, portForwardingInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterPortForwardingInfoCompleteArgs(ctx, portForwardingInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterPortForwardingInfoCompleteFlags(ctx, portForwardingInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterPortForwardingInfoCompleteArgs(ctx, portForwardingInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					portForwardingInfoParam.ParamTemplate = c.String("param-template")
					portForwardingInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(portForwardingInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewPortForwardingInfoVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(portForwardingInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						portForwardingInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						portForwardingInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						portForwardingInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						portForwardingInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						portForwardingInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						portForwardingInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						portForwardingInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						portForwardingInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						portForwardingInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						portForwardingInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						portForwardingInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = portForwardingInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if portForwardingInfoParam.GenerateSkeleton {
						portForwardingInfoParam.GenerateSkeleton = false
						portForwardingInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(portForwardingInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := portForwardingInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), portForwardingInfoParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(portForwardingInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, portForwardingInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", portForwardingInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(portForwardingInfoParam.Selector) == 0 || hasTags(&v, portForwardingInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						portForwardingInfoParam.SetId(id)
						p := *portForwardingInfoParam // copy struct value
						portForwardingInfoParam := &p
						go func() {
							err := funcs.VPCRouterPortForwardingInfo(ctx, portForwardingInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "port-forwarding-add",
				Usage:     "Add port forwarding",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "protocol",
						Usage: "[Required] set target protocol",
					},
					&cli.IntFlag{
						Name:  "global-port",
						Usage: "[Required] set global ipaddress",
					},
					&cli.StringFlag{
						Name:    "private-ipaddress",
						Aliases: []string{"private-ip", "private-address"},
						Usage:   "[Required] set private ipaddress",
					},
					&cli.IntFlag{
						Name:  "private-port",
						Usage: "[Required] set private ipaddress",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set description",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = portForwardingAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, portForwardingAddParam)

					// Set option values
					if c.IsSet("protocol") {
						portForwardingAddParam.Protocol = c.String("protocol")
					}
					if c.IsSet("global-port") {
						portForwardingAddParam.GlobalPort = c.Int("global-port")
					}
					if c.IsSet("private-ipaddress") {
						portForwardingAddParam.PrivateIpaddress = c.String("private-ipaddress")
					}
					if c.IsSet("private-port") {
						portForwardingAddParam.PrivatePort = c.Int("private-port")
					}
					if c.IsSet("description") {
						portForwardingAddParam.Description = c.String("description")
					}
					if c.IsSet("selector") {
						portForwardingAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						portForwardingAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						portForwardingAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						portForwardingAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						portForwardingAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						portForwardingAddParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterPortForwardingAddCompleteArgs(ctx, portForwardingAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterPortForwardingAddCompleteArgs(ctx, portForwardingAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterPortForwardingAddCompleteFlags(ctx, portForwardingAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterPortForwardingAddCompleteArgs(ctx, portForwardingAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					portForwardingAddParam.ParamTemplate = c.String("param-template")
					portForwardingAddParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(portForwardingAddParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewPortForwardingAddVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(portForwardingAddParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("protocol") {
						portForwardingAddParam.Protocol = c.String("protocol")
					}
					if c.IsSet("global-port") {
						portForwardingAddParam.GlobalPort = c.Int("global-port")
					}
					if c.IsSet("private-ipaddress") {
						portForwardingAddParam.PrivateIpaddress = c.String("private-ipaddress")
					}
					if c.IsSet("private-port") {
						portForwardingAddParam.PrivatePort = c.Int("private-port")
					}
					if c.IsSet("description") {
						portForwardingAddParam.Description = c.String("description")
					}
					if c.IsSet("selector") {
						portForwardingAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						portForwardingAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						portForwardingAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						portForwardingAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						portForwardingAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						portForwardingAddParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = portForwardingAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if portForwardingAddParam.GenerateSkeleton {
						portForwardingAddParam.GenerateSkeleton = false
						portForwardingAddParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(portForwardingAddParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := portForwardingAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), portForwardingAddParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(portForwardingAddParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, portForwardingAddParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", portForwardingAddParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(portForwardingAddParam.Selector) == 0 || hasTags(&v, portForwardingAddParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !portForwardingAddParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("port-forwarding-add", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						portForwardingAddParam.SetId(id)
						p := *portForwardingAddParam // copy struct value
						portForwardingAddParam := &p
						go func() {
							err := funcs.VPCRouterPortForwardingAdd(ctx, portForwardingAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "port-forwarding-update",
				Usage:     "Update port forwarding",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target PortForward",
					},
					&cli.StringFlag{
						Name:  "protocol",
						Usage: "set target protocol",
					},
					&cli.IntFlag{
						Name:  "global-port",
						Usage: "set global ipaddress",
					},
					&cli.StringFlag{
						Name:    "private-ipaddress",
						Aliases: []string{"private-ip", "private-address"},
						Usage:   "set private ipaddress",
					},
					&cli.IntFlag{
						Name:  "private-port",
						Usage: "set private ipaddress",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set description",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = portForwardingUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, portForwardingUpdateParam)

					// Set option values
					if c.IsSet("index") {
						portForwardingUpdateParam.Index = c.Int("index")
					}
					if c.IsSet("protocol") {
						portForwardingUpdateParam.Protocol = c.String("protocol")
					}
					if c.IsSet("global-port") {
						portForwardingUpdateParam.GlobalPort = c.Int("global-port")
					}
					if c.IsSet("private-ipaddress") {
						portForwardingUpdateParam.PrivateIpaddress = c.String("private-ipaddress")
					}
					if c.IsSet("private-port") {
						portForwardingUpdateParam.PrivatePort = c.Int("private-port")
					}
					if c.IsSet("description") {
						portForwardingUpdateParam.Description = c.String("description")
					}
					if c.IsSet("selector") {
						portForwardingUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						portForwardingUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						portForwardingUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						portForwardingUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						portForwardingUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						portForwardingUpdateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterPortForwardingUpdateCompleteArgs(ctx, portForwardingUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterPortForwardingUpdateCompleteArgs(ctx, portForwardingUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterPortForwardingUpdateCompleteFlags(ctx, portForwardingUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterPortForwardingUpdateCompleteArgs(ctx, portForwardingUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					portForwardingUpdateParam.ParamTemplate = c.String("param-template")
					portForwardingUpdateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(portForwardingUpdateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewPortForwardingUpdateVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(portForwardingUpdateParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("index") {
						portForwardingUpdateParam.Index = c.Int("index")
					}
					if c.IsSet("protocol") {
						portForwardingUpdateParam.Protocol = c.String("protocol")
					}
					if c.IsSet("global-port") {
						portForwardingUpdateParam.GlobalPort = c.Int("global-port")
					}
					if c.IsSet("private-ipaddress") {
						portForwardingUpdateParam.PrivateIpaddress = c.String("private-ipaddress")
					}
					if c.IsSet("private-port") {
						portForwardingUpdateParam.PrivatePort = c.Int("private-port")
					}
					if c.IsSet("description") {
						portForwardingUpdateParam.Description = c.String("description")
					}
					if c.IsSet("selector") {
						portForwardingUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						portForwardingUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						portForwardingUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						portForwardingUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						portForwardingUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						portForwardingUpdateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = portForwardingUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if portForwardingUpdateParam.GenerateSkeleton {
						portForwardingUpdateParam.GenerateSkeleton = false
						portForwardingUpdateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(portForwardingUpdateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := portForwardingUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), portForwardingUpdateParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(portForwardingUpdateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, portForwardingUpdateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", portForwardingUpdateParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(portForwardingUpdateParam.Selector) == 0 || hasTags(&v, portForwardingUpdateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !portForwardingUpdateParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("port-forwarding-update", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						portForwardingUpdateParam.SetId(id)
						p := *portForwardingUpdateParam // copy struct value
						portForwardingUpdateParam := &p
						go func() {
							err := funcs.VPCRouterPortForwardingUpdate(ctx, portForwardingUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "port-forwarding-delete",
				Usage:     "Delete port forwarding",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target PortForward",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = portForwardingDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, portForwardingDeleteParam)

					// Set option values
					if c.IsSet("index") {
						portForwardingDeleteParam.Index = c.Int("index")
					}
					if c.IsSet("selector") {
						portForwardingDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						portForwardingDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						portForwardingDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						portForwardingDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						portForwardingDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						portForwardingDeleteParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterPortForwardingDeleteCompleteArgs(ctx, portForwardingDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterPortForwardingDeleteCompleteArgs(ctx, portForwardingDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterPortForwardingDeleteCompleteFlags(ctx, portForwardingDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterPortForwardingDeleteCompleteArgs(ctx, portForwardingDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					portForwardingDeleteParam.ParamTemplate = c.String("param-template")
					portForwardingDeleteParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(portForwardingDeleteParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewPortForwardingDeleteVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(portForwardingDeleteParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("index") {
						portForwardingDeleteParam.Index = c.Int("index")
					}
					if c.IsSet("selector") {
						portForwardingDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						portForwardingDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						portForwardingDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						portForwardingDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						portForwardingDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						portForwardingDeleteParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = portForwardingDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if portForwardingDeleteParam.GenerateSkeleton {
						portForwardingDeleteParam.GenerateSkeleton = false
						portForwardingDeleteParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(portForwardingDeleteParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := portForwardingDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), portForwardingDeleteParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(portForwardingDeleteParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, portForwardingDeleteParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", portForwardingDeleteParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(portForwardingDeleteParam.Selector) == 0 || hasTags(&v, portForwardingDeleteParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !portForwardingDeleteParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("port-forwarding-delete", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						portForwardingDeleteParam.SetId(id)
						p := *portForwardingDeleteParam // copy struct value
						portForwardingDeleteParam := &p
						go func() {
							err := funcs.VPCRouterPortForwardingDelete(ctx, portForwardingDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "firewall-info",
				Aliases:   []string{"firewall-list"},
				Usage:     "Show information of firewall rules",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "interface",
						Usage: "set target NIC index",
						Value: 0,
					},
					&cli.StringFlag{
						Name:  "direction",
						Usage: "[Required] set target direction[send/receive]",
						Value: "receive",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = firewallInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, firewallInfoParam)

					// Set option values
					if c.IsSet("interface") {
						firewallInfoParam.Interface = c.Int("interface")
					}
					if c.IsSet("direction") {
						firewallInfoParam.Direction = c.String("direction")
					}
					if c.IsSet("selector") {
						firewallInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						firewallInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						firewallInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						firewallInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						firewallInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						firewallInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						firewallInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						firewallInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						firewallInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						firewallInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						firewallInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterFirewallInfoCompleteArgs(ctx, firewallInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterFirewallInfoCompleteArgs(ctx, firewallInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterFirewallInfoCompleteFlags(ctx, firewallInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterFirewallInfoCompleteArgs(ctx, firewallInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					firewallInfoParam.ParamTemplate = c.String("param-template")
					firewallInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(firewallInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewFirewallInfoVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(firewallInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("interface") {
						firewallInfoParam.Interface = c.Int("interface")
					}
					if c.IsSet("direction") {
						firewallInfoParam.Direction = c.String("direction")
					}
					if c.IsSet("selector") {
						firewallInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						firewallInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						firewallInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						firewallInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						firewallInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						firewallInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						firewallInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						firewallInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						firewallInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						firewallInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						firewallInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = firewallInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if firewallInfoParam.GenerateSkeleton {
						firewallInfoParam.GenerateSkeleton = false
						firewallInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(firewallInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := firewallInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), firewallInfoParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(firewallInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, firewallInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", firewallInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(firewallInfoParam.Selector) == 0 || hasTags(&v, firewallInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						firewallInfoParam.SetId(id)
						p := *firewallInfoParam // copy struct value
						firewallInfoParam := &p
						go func() {
							err := funcs.VPCRouterFirewallInfo(ctx, firewallInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "firewall-add",
				Usage:     "Add firewall rule",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "interface",
						Usage: "set target NIC index",
						Value: 0,
					},
					&cli.StringFlag{
						Name:  "direction",
						Usage: "[Required] set target direction[send/receive]",
						Value: "receive",
					},
					&cli.StringFlag{
						Name:  "protocol",
						Usage: "[Required] set target protocol",
					},
					&cli.StringFlag{
						Name:  "source-network",
						Usage: "set source ipaddress or network address",
					},
					&cli.IntFlag{
						Name:  "source-port",
						Usage: "set source port",
					},
					&cli.StringFlag{
						Name:    "destination-network",
						Aliases: []string{"dest-network"},
						Usage:   "set destination ipaddress or network address",
					},
					&cli.IntFlag{
						Name:    "destination-port",
						Aliases: []string{"dest-port"},
						Usage:   "set destination port",
					},
					&cli.StringFlag{
						Name:  "action",
						Usage: "[Required] set action[allow/deny]",
						Value: "deny",
					},
					&cli.BoolFlag{
						Name:  "enable-logging",
						Usage: "enable logging",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set description",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = firewallAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, firewallAddParam)

					// Set option values
					if c.IsSet("interface") {
						firewallAddParam.Interface = c.Int("interface")
					}
					if c.IsSet("direction") {
						firewallAddParam.Direction = c.String("direction")
					}
					if c.IsSet("protocol") {
						firewallAddParam.Protocol = c.String("protocol")
					}
					if c.IsSet("source-network") {
						firewallAddParam.SourceNetwork = c.String("source-network")
					}
					if c.IsSet("source-port") {
						firewallAddParam.SourcePort = c.Int("source-port")
					}
					if c.IsSet("destination-network") {
						firewallAddParam.DestinationNetwork = c.String("destination-network")
					}
					if c.IsSet("destination-port") {
						firewallAddParam.DestinationPort = c.Int("destination-port")
					}
					if c.IsSet("action") {
						firewallAddParam.Action = c.String("action")
					}
					if c.IsSet("enable-logging") {
						firewallAddParam.EnableLogging = c.Bool("enable-logging")
					}
					if c.IsSet("description") {
						firewallAddParam.Description = c.String("description")
					}
					if c.IsSet("selector") {
						firewallAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						firewallAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						firewallAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						firewallAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						firewallAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						firewallAddParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterFirewallAddCompleteArgs(ctx, firewallAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterFirewallAddCompleteArgs(ctx, firewallAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterFirewallAddCompleteFlags(ctx, firewallAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterFirewallAddCompleteArgs(ctx, firewallAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					firewallAddParam.ParamTemplate = c.String("param-template")
					firewallAddParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(firewallAddParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewFirewallAddVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(firewallAddParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("interface") {
						firewallAddParam.Interface = c.Int("interface")
					}
					if c.IsSet("direction") {
						firewallAddParam.Direction = c.String("direction")
					}
					if c.IsSet("protocol") {
						firewallAddParam.Protocol = c.String("protocol")
					}
					if c.IsSet("source-network") {
						firewallAddParam.SourceNetwork = c.String("source-network")
					}
					if c.IsSet("source-port") {
						firewallAddParam.SourcePort = c.Int("source-port")
					}
					if c.IsSet("destination-network") {
						firewallAddParam.DestinationNetwork = c.String("destination-network")
					}
					if c.IsSet("destination-port") {
						firewallAddParam.DestinationPort = c.Int("destination-port")
					}
					if c.IsSet("action") {
						firewallAddParam.Action = c.String("action")
					}
					if c.IsSet("enable-logging") {
						firewallAddParam.EnableLogging = c.Bool("enable-logging")
					}
					if c.IsSet("description") {
						firewallAddParam.Description = c.String("description")
					}
					if c.IsSet("selector") {
						firewallAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						firewallAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						firewallAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						firewallAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						firewallAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						firewallAddParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = firewallAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if firewallAddParam.GenerateSkeleton {
						firewallAddParam.GenerateSkeleton = false
						firewallAddParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(firewallAddParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := firewallAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), firewallAddParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(firewallAddParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, firewallAddParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", firewallAddParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(firewallAddParam.Selector) == 0 || hasTags(&v, firewallAddParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !firewallAddParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("firewall-add", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						firewallAddParam.SetId(id)
						p := *firewallAddParam // copy struct value
						firewallAddParam := &p
						go func() {
							err := funcs.VPCRouterFirewallAdd(ctx, firewallAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "firewall-update",
				Usage:     "Update firewall rule",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "interface",
						Usage: "set target NIC index",
						Value: 0,
					},
					&cli.StringFlag{
						Name:  "direction",
						Usage: "[Required] set target direction[send/receive]",
						Value: "receive",
					},
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target Firewall rule",
					},
					&cli.StringFlag{
						Name:  "protocol",
						Usage: "set target protocol",
					},
					&cli.StringFlag{
						Name:  "source-network",
						Usage: "set source ipaddress or network address",
					},
					&cli.IntFlag{
						Name:  "source-port",
						Usage: "set source port",
					},
					&cli.StringFlag{
						Name:    "destination-network",
						Aliases: []string{"dest-network"},
						Usage:   "set destination ipaddress or network address",
					},
					&cli.IntFlag{
						Name:    "destination-port",
						Aliases: []string{"dest-port"},
						Usage:   "set destination port",
					},
					&cli.StringFlag{
						Name:  "action",
						Usage: "set action[allow/deny]",
						Value: "deny",
					},
					&cli.BoolFlag{
						Name:  "enable-logging",
						Usage: "enable logging",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set description",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = firewallUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, firewallUpdateParam)

					// Set option values
					if c.IsSet("interface") {
						firewallUpdateParam.Interface = c.Int("interface")
					}
					if c.IsSet("direction") {
						firewallUpdateParam.Direction = c.String("direction")
					}
					if c.IsSet("index") {
						firewallUpdateParam.Index = c.Int("index")
					}
					if c.IsSet("protocol") {
						firewallUpdateParam.Protocol = c.String("protocol")
					}
					if c.IsSet("source-network") {
						firewallUpdateParam.SourceNetwork = c.String("source-network")
					}
					if c.IsSet("source-port") {
						firewallUpdateParam.SourcePort = c.Int("source-port")
					}
					if c.IsSet("destination-network") {
						firewallUpdateParam.DestinationNetwork = c.String("destination-network")
					}
					if c.IsSet("destination-port") {
						firewallUpdateParam.DestinationPort = c.Int("destination-port")
					}
					if c.IsSet("action") {
						firewallUpdateParam.Action = c.String("action")
					}
					if c.IsSet("enable-logging") {
						firewallUpdateParam.EnableLogging = c.Bool("enable-logging")
					}
					if c.IsSet("description") {
						firewallUpdateParam.Description = c.String("description")
					}
					if c.IsSet("selector") {
						firewallUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						firewallUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						firewallUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						firewallUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						firewallUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						firewallUpdateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterFirewallUpdateCompleteArgs(ctx, firewallUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterFirewallUpdateCompleteArgs(ctx, firewallUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterFirewallUpdateCompleteFlags(ctx, firewallUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterFirewallUpdateCompleteArgs(ctx, firewallUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					firewallUpdateParam.ParamTemplate = c.String("param-template")
					firewallUpdateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(firewallUpdateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewFirewallUpdateVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(firewallUpdateParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("interface") {
						firewallUpdateParam.Interface = c.Int("interface")
					}
					if c.IsSet("direction") {
						firewallUpdateParam.Direction = c.String("direction")
					}
					if c.IsSet("index") {
						firewallUpdateParam.Index = c.Int("index")
					}
					if c.IsSet("protocol") {
						firewallUpdateParam.Protocol = c.String("protocol")
					}
					if c.IsSet("source-network") {
						firewallUpdateParam.SourceNetwork = c.String("source-network")
					}
					if c.IsSet("source-port") {
						firewallUpdateParam.SourcePort = c.Int("source-port")
					}
					if c.IsSet("destination-network") {
						firewallUpdateParam.DestinationNetwork = c.String("destination-network")
					}
					if c.IsSet("destination-port") {
						firewallUpdateParam.DestinationPort = c.Int("destination-port")
					}
					if c.IsSet("action") {
						firewallUpdateParam.Action = c.String("action")
					}
					if c.IsSet("enable-logging") {
						firewallUpdateParam.EnableLogging = c.Bool("enable-logging")
					}
					if c.IsSet("description") {
						firewallUpdateParam.Description = c.String("description")
					}
					if c.IsSet("selector") {
						firewallUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						firewallUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						firewallUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						firewallUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						firewallUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						firewallUpdateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = firewallUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if firewallUpdateParam.GenerateSkeleton {
						firewallUpdateParam.GenerateSkeleton = false
						firewallUpdateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(firewallUpdateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := firewallUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), firewallUpdateParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(firewallUpdateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, firewallUpdateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", firewallUpdateParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(firewallUpdateParam.Selector) == 0 || hasTags(&v, firewallUpdateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !firewallUpdateParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("firewall-update", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						firewallUpdateParam.SetId(id)
						p := *firewallUpdateParam // copy struct value
						firewallUpdateParam := &p
						go func() {
							err := funcs.VPCRouterFirewallUpdate(ctx, firewallUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "firewall-delete",
				Usage:     "Delete firewall rule",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "interface",
						Usage: "set target NIC index",
						Value: 0,
					},
					&cli.StringFlag{
						Name:  "direction",
						Usage: "[Required] set target direction[send/receive]",
						Value: "receive",
					},
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target Firewall rule",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = firewallDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, firewallDeleteParam)

					// Set option values
					if c.IsSet("interface") {
						firewallDeleteParam.Interface = c.Int("interface")
					}
					if c.IsSet("direction") {
						firewallDeleteParam.Direction = c.String("direction")
					}
					if c.IsSet("index") {
						firewallDeleteParam.Index = c.Int("index")
					}
					if c.IsSet("selector") {
						firewallDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						firewallDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						firewallDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						firewallDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						firewallDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						firewallDeleteParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterFirewallDeleteCompleteArgs(ctx, firewallDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterFirewallDeleteCompleteArgs(ctx, firewallDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterFirewallDeleteCompleteFlags(ctx, firewallDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterFirewallDeleteCompleteArgs(ctx, firewallDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					firewallDeleteParam.ParamTemplate = c.String("param-template")
					firewallDeleteParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(firewallDeleteParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewFirewallDeleteVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(firewallDeleteParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("interface") {
						firewallDeleteParam.Interface = c.Int("interface")
					}
					if c.IsSet("direction") {
						firewallDeleteParam.Direction = c.String("direction")
					}
					if c.IsSet("index") {
						firewallDeleteParam.Index = c.Int("index")
					}
					if c.IsSet("selector") {
						firewallDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						firewallDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						firewallDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						firewallDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						firewallDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						firewallDeleteParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = firewallDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if firewallDeleteParam.GenerateSkeleton {
						firewallDeleteParam.GenerateSkeleton = false
						firewallDeleteParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(firewallDeleteParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := firewallDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), firewallDeleteParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(firewallDeleteParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, firewallDeleteParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", firewallDeleteParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(firewallDeleteParam.Selector) == 0 || hasTags(&v, firewallDeleteParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !firewallDeleteParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("firewall-delete", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						firewallDeleteParam.SetId(id)
						p := *firewallDeleteParam // copy struct value
						firewallDeleteParam := &p
						go func() {
							err := funcs.VPCRouterFirewallDelete(ctx, firewallDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-server-info",
				Aliases:   []string{"dhcp-server-list"},
				Usage:     "Show information of DHCP servers",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = dhcpServerInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpServerInfoParam)

					// Set option values
					if c.IsSet("selector") {
						dhcpServerInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						dhcpServerInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpServerInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpServerInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						dhcpServerInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						dhcpServerInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						dhcpServerInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						dhcpServerInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						dhcpServerInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						dhcpServerInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						dhcpServerInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpServerInfoCompleteArgs(ctx, dhcpServerInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpServerInfoCompleteArgs(ctx, dhcpServerInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpServerInfoCompleteFlags(ctx, dhcpServerInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpServerInfoCompleteArgs(ctx, dhcpServerInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					dhcpServerInfoParam.ParamTemplate = c.String("param-template")
					dhcpServerInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(dhcpServerInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDhcpServerInfoVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(dhcpServerInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						dhcpServerInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						dhcpServerInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpServerInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpServerInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						dhcpServerInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						dhcpServerInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						dhcpServerInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						dhcpServerInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						dhcpServerInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						dhcpServerInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						dhcpServerInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = dhcpServerInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if dhcpServerInfoParam.GenerateSkeleton {
						dhcpServerInfoParam.GenerateSkeleton = false
						dhcpServerInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(dhcpServerInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := dhcpServerInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpServerInfoParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(dhcpServerInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, dhcpServerInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", dhcpServerInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(dhcpServerInfoParam.Selector) == 0 || hasTags(&v, dhcpServerInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpServerInfoParam.SetId(id)
						p := *dhcpServerInfoParam // copy struct value
						dhcpServerInfoParam := &p
						go func() {
							err := funcs.VPCRouterDhcpServerInfo(ctx, dhcpServerInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-server-add",
				Usage:     "Add DHCP server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "interface",
						Usage: "[Required] set target NIC(private NIC index)",
					},
					&cli.StringFlag{
						Name:  "range-start",
						Usage: "[Required] set DHCP IPAddress Range(start)",
					},
					&cli.StringFlag{
						Name:    "range-stop",
						Aliases: []string{"range-end"},
						Usage:   "[Required] set DHCP IPAddress Range(stop)",
					},
					&cli.StringSliceFlag{
						Name:  "dns-servers",
						Usage: "set DNS Server IPAddress",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = dhcpServerAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpServerAddParam)

					// Set option values
					if c.IsSet("interface") {
						dhcpServerAddParam.Interface = c.Int("interface")
					}
					if c.IsSet("range-start") {
						dhcpServerAddParam.RangeStart = c.String("range-start")
					}
					if c.IsSet("range-stop") {
						dhcpServerAddParam.RangeStop = c.String("range-stop")
					}
					if c.IsSet("dns-servers") {
						dhcpServerAddParam.DnsServers = c.StringSlice("dns-servers")
					}
					if c.IsSet("selector") {
						dhcpServerAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						dhcpServerAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						dhcpServerAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpServerAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpServerAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						dhcpServerAddParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpServerAddCompleteArgs(ctx, dhcpServerAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpServerAddCompleteArgs(ctx, dhcpServerAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpServerAddCompleteFlags(ctx, dhcpServerAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpServerAddCompleteArgs(ctx, dhcpServerAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					dhcpServerAddParam.ParamTemplate = c.String("param-template")
					dhcpServerAddParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(dhcpServerAddParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDhcpServerAddVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(dhcpServerAddParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("interface") {
						dhcpServerAddParam.Interface = c.Int("interface")
					}
					if c.IsSet("range-start") {
						dhcpServerAddParam.RangeStart = c.String("range-start")
					}
					if c.IsSet("range-stop") {
						dhcpServerAddParam.RangeStop = c.String("range-stop")
					}
					if c.IsSet("dns-servers") {
						dhcpServerAddParam.DnsServers = c.StringSlice("dns-servers")
					}
					if c.IsSet("selector") {
						dhcpServerAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						dhcpServerAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						dhcpServerAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpServerAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpServerAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						dhcpServerAddParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = dhcpServerAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if dhcpServerAddParam.GenerateSkeleton {
						dhcpServerAddParam.GenerateSkeleton = false
						dhcpServerAddParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(dhcpServerAddParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := dhcpServerAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpServerAddParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(dhcpServerAddParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, dhcpServerAddParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", dhcpServerAddParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(dhcpServerAddParam.Selector) == 0 || hasTags(&v, dhcpServerAddParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !dhcpServerAddParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("dhcp-server-add", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpServerAddParam.SetId(id)
						p := *dhcpServerAddParam // copy struct value
						dhcpServerAddParam := &p
						go func() {
							err := funcs.VPCRouterDhcpServerAdd(ctx, dhcpServerAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-server-update",
				Usage:     "Update DHCP server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "interface",
						Usage: "[Required] set target NIC(private NIC index)",
					},
					&cli.StringFlag{
						Name:  "range-start",
						Usage: "set DHCP IPAddress Range(start)",
					},
					&cli.StringFlag{
						Name:    "range-stop",
						Aliases: []string{"range-end"},
						Usage:   "set DHCP IPAddress Range(stop)",
					},
					&cli.StringSliceFlag{
						Name:  "dns-servers",
						Usage: "set DNS Server IPAddress",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = dhcpServerUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpServerUpdateParam)

					// Set option values
					if c.IsSet("interface") {
						dhcpServerUpdateParam.Interface = c.Int("interface")
					}
					if c.IsSet("range-start") {
						dhcpServerUpdateParam.RangeStart = c.String("range-start")
					}
					if c.IsSet("range-stop") {
						dhcpServerUpdateParam.RangeStop = c.String("range-stop")
					}
					if c.IsSet("dns-servers") {
						dhcpServerUpdateParam.DnsServers = c.StringSlice("dns-servers")
					}
					if c.IsSet("selector") {
						dhcpServerUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						dhcpServerUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						dhcpServerUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpServerUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpServerUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						dhcpServerUpdateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpServerUpdateCompleteArgs(ctx, dhcpServerUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpServerUpdateCompleteArgs(ctx, dhcpServerUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpServerUpdateCompleteFlags(ctx, dhcpServerUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpServerUpdateCompleteArgs(ctx, dhcpServerUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					dhcpServerUpdateParam.ParamTemplate = c.String("param-template")
					dhcpServerUpdateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(dhcpServerUpdateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDhcpServerUpdateVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(dhcpServerUpdateParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("interface") {
						dhcpServerUpdateParam.Interface = c.Int("interface")
					}
					if c.IsSet("range-start") {
						dhcpServerUpdateParam.RangeStart = c.String("range-start")
					}
					if c.IsSet("range-stop") {
						dhcpServerUpdateParam.RangeStop = c.String("range-stop")
					}
					if c.IsSet("dns-servers") {
						dhcpServerUpdateParam.DnsServers = c.StringSlice("dns-servers")
					}
					if c.IsSet("selector") {
						dhcpServerUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						dhcpServerUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						dhcpServerUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpServerUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpServerUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						dhcpServerUpdateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = dhcpServerUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if dhcpServerUpdateParam.GenerateSkeleton {
						dhcpServerUpdateParam.GenerateSkeleton = false
						dhcpServerUpdateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(dhcpServerUpdateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := dhcpServerUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpServerUpdateParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(dhcpServerUpdateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, dhcpServerUpdateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", dhcpServerUpdateParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(dhcpServerUpdateParam.Selector) == 0 || hasTags(&v, dhcpServerUpdateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !dhcpServerUpdateParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("dhcp-server-update", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpServerUpdateParam.SetId(id)
						p := *dhcpServerUpdateParam // copy struct value
						dhcpServerUpdateParam := &p
						go func() {
							err := funcs.VPCRouterDhcpServerUpdate(ctx, dhcpServerUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-server-delete",
				Usage:     "Delete DHCP server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "interface",
						Usage: "[Required] set target NIC(private NIC index)",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = dhcpServerDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpServerDeleteParam)

					// Set option values
					if c.IsSet("interface") {
						dhcpServerDeleteParam.Interface = c.Int("interface")
					}
					if c.IsSet("selector") {
						dhcpServerDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						dhcpServerDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						dhcpServerDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpServerDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpServerDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						dhcpServerDeleteParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpServerDeleteCompleteArgs(ctx, dhcpServerDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpServerDeleteCompleteArgs(ctx, dhcpServerDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpServerDeleteCompleteFlags(ctx, dhcpServerDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpServerDeleteCompleteArgs(ctx, dhcpServerDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					dhcpServerDeleteParam.ParamTemplate = c.String("param-template")
					dhcpServerDeleteParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(dhcpServerDeleteParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDhcpServerDeleteVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(dhcpServerDeleteParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("interface") {
						dhcpServerDeleteParam.Interface = c.Int("interface")
					}
					if c.IsSet("selector") {
						dhcpServerDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						dhcpServerDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						dhcpServerDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpServerDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpServerDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						dhcpServerDeleteParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = dhcpServerDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if dhcpServerDeleteParam.GenerateSkeleton {
						dhcpServerDeleteParam.GenerateSkeleton = false
						dhcpServerDeleteParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(dhcpServerDeleteParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := dhcpServerDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpServerDeleteParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(dhcpServerDeleteParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, dhcpServerDeleteParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", dhcpServerDeleteParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(dhcpServerDeleteParam.Selector) == 0 || hasTags(&v, dhcpServerDeleteParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !dhcpServerDeleteParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("dhcp-server-delete", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpServerDeleteParam.SetId(id)
						p := *dhcpServerDeleteParam // copy struct value
						dhcpServerDeleteParam := &p
						go func() {
							err := funcs.VPCRouterDhcpServerDelete(ctx, dhcpServerDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-static-mapping-info",
				Aliases:   []string{"dhcp-static-mapping-list"},
				Usage:     "Show information of DHCP static mapping",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = dhcpStaticMappingInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpStaticMappingInfoParam)

					// Set option values
					if c.IsSet("selector") {
						dhcpStaticMappingInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						dhcpStaticMappingInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpStaticMappingInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpStaticMappingInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						dhcpStaticMappingInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						dhcpStaticMappingInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						dhcpStaticMappingInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						dhcpStaticMappingInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						dhcpStaticMappingInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						dhcpStaticMappingInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						dhcpStaticMappingInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpStaticMappingInfoCompleteArgs(ctx, dhcpStaticMappingInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpStaticMappingInfoCompleteArgs(ctx, dhcpStaticMappingInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpStaticMappingInfoCompleteFlags(ctx, dhcpStaticMappingInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpStaticMappingInfoCompleteArgs(ctx, dhcpStaticMappingInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					dhcpStaticMappingInfoParam.ParamTemplate = c.String("param-template")
					dhcpStaticMappingInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(dhcpStaticMappingInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDhcpStaticMappingInfoVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(dhcpStaticMappingInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						dhcpStaticMappingInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						dhcpStaticMappingInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpStaticMappingInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpStaticMappingInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						dhcpStaticMappingInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						dhcpStaticMappingInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						dhcpStaticMappingInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						dhcpStaticMappingInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						dhcpStaticMappingInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						dhcpStaticMappingInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						dhcpStaticMappingInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = dhcpStaticMappingInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if dhcpStaticMappingInfoParam.GenerateSkeleton {
						dhcpStaticMappingInfoParam.GenerateSkeleton = false
						dhcpStaticMappingInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(dhcpStaticMappingInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := dhcpStaticMappingInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpStaticMappingInfoParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(dhcpStaticMappingInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, dhcpStaticMappingInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", dhcpStaticMappingInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(dhcpStaticMappingInfoParam.Selector) == 0 || hasTags(&v, dhcpStaticMappingInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpStaticMappingInfoParam.SetId(id)
						p := *dhcpStaticMappingInfoParam // copy struct value
						dhcpStaticMappingInfoParam := &p
						go func() {
							err := funcs.VPCRouterDhcpStaticMappingInfo(ctx, dhcpStaticMappingInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-static-mapping-add",
				Usage:     "Add DHCP static mapping",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "macaddress",
						Aliases: []string{"mac"},
						Usage:   "[Required] set mac address",
					},
					&cli.StringFlag{
						Name:    "ipaddress",
						Aliases: []string{"ip"},
						Usage:   "[Required] set ipaddress",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = dhcpStaticMappingAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpStaticMappingAddParam)

					// Set option values
					if c.IsSet("macaddress") {
						dhcpStaticMappingAddParam.Macaddress = c.String("macaddress")
					}
					if c.IsSet("ipaddress") {
						dhcpStaticMappingAddParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("selector") {
						dhcpStaticMappingAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						dhcpStaticMappingAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						dhcpStaticMappingAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpStaticMappingAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpStaticMappingAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						dhcpStaticMappingAddParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpStaticMappingAddCompleteArgs(ctx, dhcpStaticMappingAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpStaticMappingAddCompleteArgs(ctx, dhcpStaticMappingAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpStaticMappingAddCompleteFlags(ctx, dhcpStaticMappingAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpStaticMappingAddCompleteArgs(ctx, dhcpStaticMappingAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					dhcpStaticMappingAddParam.ParamTemplate = c.String("param-template")
					dhcpStaticMappingAddParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(dhcpStaticMappingAddParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDhcpStaticMappingAddVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(dhcpStaticMappingAddParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("macaddress") {
						dhcpStaticMappingAddParam.Macaddress = c.String("macaddress")
					}
					if c.IsSet("ipaddress") {
						dhcpStaticMappingAddParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("selector") {
						dhcpStaticMappingAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						dhcpStaticMappingAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						dhcpStaticMappingAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpStaticMappingAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpStaticMappingAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						dhcpStaticMappingAddParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = dhcpStaticMappingAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if dhcpStaticMappingAddParam.GenerateSkeleton {
						dhcpStaticMappingAddParam.GenerateSkeleton = false
						dhcpStaticMappingAddParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(dhcpStaticMappingAddParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := dhcpStaticMappingAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpStaticMappingAddParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(dhcpStaticMappingAddParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, dhcpStaticMappingAddParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", dhcpStaticMappingAddParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(dhcpStaticMappingAddParam.Selector) == 0 || hasTags(&v, dhcpStaticMappingAddParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !dhcpStaticMappingAddParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("dhcp-static-mapping-add", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpStaticMappingAddParam.SetId(id)
						p := *dhcpStaticMappingAddParam // copy struct value
						dhcpStaticMappingAddParam := &p
						go func() {
							err := funcs.VPCRouterDhcpStaticMappingAdd(ctx, dhcpStaticMappingAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-static-mapping-update",
				Usage:     "Update DHCP static mapping",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target DHCP static mapping",
					},
					&cli.StringFlag{
						Name:    "macaddress",
						Aliases: []string{"mac"},
						Usage:   "set mac address",
					},
					&cli.StringFlag{
						Name:    "ipaddress",
						Aliases: []string{"ip"},
						Usage:   "set ipaddress",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = dhcpStaticMappingUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpStaticMappingUpdateParam)

					// Set option values
					if c.IsSet("index") {
						dhcpStaticMappingUpdateParam.Index = c.Int("index")
					}
					if c.IsSet("macaddress") {
						dhcpStaticMappingUpdateParam.Macaddress = c.String("macaddress")
					}
					if c.IsSet("ipaddress") {
						dhcpStaticMappingUpdateParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("selector") {
						dhcpStaticMappingUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						dhcpStaticMappingUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						dhcpStaticMappingUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpStaticMappingUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpStaticMappingUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						dhcpStaticMappingUpdateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpStaticMappingUpdateCompleteArgs(ctx, dhcpStaticMappingUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpStaticMappingUpdateCompleteArgs(ctx, dhcpStaticMappingUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpStaticMappingUpdateCompleteFlags(ctx, dhcpStaticMappingUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpStaticMappingUpdateCompleteArgs(ctx, dhcpStaticMappingUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					dhcpStaticMappingUpdateParam.ParamTemplate = c.String("param-template")
					dhcpStaticMappingUpdateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(dhcpStaticMappingUpdateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDhcpStaticMappingUpdateVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(dhcpStaticMappingUpdateParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("index") {
						dhcpStaticMappingUpdateParam.Index = c.Int("index")
					}
					if c.IsSet("macaddress") {
						dhcpStaticMappingUpdateParam.Macaddress = c.String("macaddress")
					}
					if c.IsSet("ipaddress") {
						dhcpStaticMappingUpdateParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("selector") {
						dhcpStaticMappingUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						dhcpStaticMappingUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						dhcpStaticMappingUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpStaticMappingUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpStaticMappingUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						dhcpStaticMappingUpdateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = dhcpStaticMappingUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if dhcpStaticMappingUpdateParam.GenerateSkeleton {
						dhcpStaticMappingUpdateParam.GenerateSkeleton = false
						dhcpStaticMappingUpdateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(dhcpStaticMappingUpdateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := dhcpStaticMappingUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpStaticMappingUpdateParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(dhcpStaticMappingUpdateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, dhcpStaticMappingUpdateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", dhcpStaticMappingUpdateParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(dhcpStaticMappingUpdateParam.Selector) == 0 || hasTags(&v, dhcpStaticMappingUpdateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !dhcpStaticMappingUpdateParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("dhcp-static-mapping-update", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpStaticMappingUpdateParam.SetId(id)
						p := *dhcpStaticMappingUpdateParam // copy struct value
						dhcpStaticMappingUpdateParam := &p
						go func() {
							err := funcs.VPCRouterDhcpStaticMappingUpdate(ctx, dhcpStaticMappingUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "dhcp-static-mapping-delete",
				Usage:     "Delete DHCP static mapping",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target DHCP static mapping",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = dhcpStaticMappingDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, dhcpStaticMappingDeleteParam)

					// Set option values
					if c.IsSet("index") {
						dhcpStaticMappingDeleteParam.Index = c.Int("index")
					}
					if c.IsSet("selector") {
						dhcpStaticMappingDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						dhcpStaticMappingDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						dhcpStaticMappingDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpStaticMappingDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpStaticMappingDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						dhcpStaticMappingDeleteParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterDhcpStaticMappingDeleteCompleteArgs(ctx, dhcpStaticMappingDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterDhcpStaticMappingDeleteCompleteArgs(ctx, dhcpStaticMappingDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterDhcpStaticMappingDeleteCompleteFlags(ctx, dhcpStaticMappingDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterDhcpStaticMappingDeleteCompleteArgs(ctx, dhcpStaticMappingDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					dhcpStaticMappingDeleteParam.ParamTemplate = c.String("param-template")
					dhcpStaticMappingDeleteParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(dhcpStaticMappingDeleteParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDhcpStaticMappingDeleteVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(dhcpStaticMappingDeleteParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("index") {
						dhcpStaticMappingDeleteParam.Index = c.Int("index")
					}
					if c.IsSet("selector") {
						dhcpStaticMappingDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						dhcpStaticMappingDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						dhcpStaticMappingDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						dhcpStaticMappingDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						dhcpStaticMappingDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						dhcpStaticMappingDeleteParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = dhcpStaticMappingDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if dhcpStaticMappingDeleteParam.GenerateSkeleton {
						dhcpStaticMappingDeleteParam.GenerateSkeleton = false
						dhcpStaticMappingDeleteParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(dhcpStaticMappingDeleteParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := dhcpStaticMappingDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), dhcpStaticMappingDeleteParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(dhcpStaticMappingDeleteParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, dhcpStaticMappingDeleteParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", dhcpStaticMappingDeleteParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(dhcpStaticMappingDeleteParam.Selector) == 0 || hasTags(&v, dhcpStaticMappingDeleteParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !dhcpStaticMappingDeleteParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("dhcp-static-mapping-delete", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						dhcpStaticMappingDeleteParam.SetId(id)
						p := *dhcpStaticMappingDeleteParam // copy struct value
						dhcpStaticMappingDeleteParam := &p
						go func() {
							err := funcs.VPCRouterDhcpStaticMappingDelete(ctx, dhcpStaticMappingDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "pptp-server-info",
				Usage:     "Show information of PPTP server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = pptpServerInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, pptpServerInfoParam)

					// Set option values
					if c.IsSet("selector") {
						pptpServerInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						pptpServerInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						pptpServerInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						pptpServerInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						pptpServerInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						pptpServerInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						pptpServerInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						pptpServerInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						pptpServerInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						pptpServerInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						pptpServerInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterPptpServerInfoCompleteArgs(ctx, pptpServerInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterPptpServerInfoCompleteArgs(ctx, pptpServerInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterPptpServerInfoCompleteFlags(ctx, pptpServerInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterPptpServerInfoCompleteArgs(ctx, pptpServerInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					pptpServerInfoParam.ParamTemplate = c.String("param-template")
					pptpServerInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(pptpServerInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewPptpServerInfoVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(pptpServerInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						pptpServerInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						pptpServerInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						pptpServerInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						pptpServerInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						pptpServerInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						pptpServerInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						pptpServerInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						pptpServerInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						pptpServerInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						pptpServerInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						pptpServerInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = pptpServerInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if pptpServerInfoParam.GenerateSkeleton {
						pptpServerInfoParam.GenerateSkeleton = false
						pptpServerInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(pptpServerInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := pptpServerInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), pptpServerInfoParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(pptpServerInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, pptpServerInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", pptpServerInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(pptpServerInfoParam.Selector) == 0 || hasTags(&v, pptpServerInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						pptpServerInfoParam.SetId(id)
						p := *pptpServerInfoParam // copy struct value
						pptpServerInfoParam := &p
						go func() {
							err := funcs.VPCRouterPptpServerInfo(ctx, pptpServerInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "pptp-server-update",
				Usage:     "Update PPTP server setting",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:  "disabled",
						Usage: "enable/disable PPTP server",
					},
					&cli.StringFlag{
						Name:  "range-start",
						Usage: "set IPAddress Range(start)",
					},
					&cli.StringFlag{
						Name:    "range-stop",
						Aliases: []string{"range-end"},
						Usage:   "set IPAddress Range(stop)",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = pptpServerUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, pptpServerUpdateParam)

					// Set option values
					if c.IsSet("disabled") {
						pptpServerUpdateParam.Disabled = c.Bool("disabled")
					}
					if c.IsSet("range-start") {
						pptpServerUpdateParam.RangeStart = c.String("range-start")
					}
					if c.IsSet("range-stop") {
						pptpServerUpdateParam.RangeStop = c.String("range-stop")
					}
					if c.IsSet("selector") {
						pptpServerUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						pptpServerUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						pptpServerUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						pptpServerUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						pptpServerUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						pptpServerUpdateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterPptpServerUpdateCompleteArgs(ctx, pptpServerUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterPptpServerUpdateCompleteArgs(ctx, pptpServerUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterPptpServerUpdateCompleteFlags(ctx, pptpServerUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterPptpServerUpdateCompleteArgs(ctx, pptpServerUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					pptpServerUpdateParam.ParamTemplate = c.String("param-template")
					pptpServerUpdateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(pptpServerUpdateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewPptpServerUpdateVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(pptpServerUpdateParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("disabled") {
						pptpServerUpdateParam.Disabled = c.Bool("disabled")
					}
					if c.IsSet("range-start") {
						pptpServerUpdateParam.RangeStart = c.String("range-start")
					}
					if c.IsSet("range-stop") {
						pptpServerUpdateParam.RangeStop = c.String("range-stop")
					}
					if c.IsSet("selector") {
						pptpServerUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						pptpServerUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						pptpServerUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						pptpServerUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						pptpServerUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						pptpServerUpdateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = pptpServerUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if pptpServerUpdateParam.GenerateSkeleton {
						pptpServerUpdateParam.GenerateSkeleton = false
						pptpServerUpdateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(pptpServerUpdateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := pptpServerUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), pptpServerUpdateParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(pptpServerUpdateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, pptpServerUpdateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", pptpServerUpdateParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(pptpServerUpdateParam.Selector) == 0 || hasTags(&v, pptpServerUpdateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !pptpServerUpdateParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("pptp-server-update", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						pptpServerUpdateParam.SetId(id)
						p := *pptpServerUpdateParam // copy struct value
						pptpServerUpdateParam := &p
						go func() {
							err := funcs.VPCRouterPptpServerUpdate(ctx, pptpServerUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "l2tp-server-info",
				Usage:     "Show information of L2TP/IPSec server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = l2tpServerInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, l2tpServerInfoParam)

					// Set option values
					if c.IsSet("selector") {
						l2tpServerInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						l2tpServerInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						l2tpServerInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						l2tpServerInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						l2tpServerInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						l2tpServerInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						l2tpServerInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						l2tpServerInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						l2tpServerInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						l2tpServerInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						l2tpServerInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterL2tpServerInfoCompleteArgs(ctx, l2tpServerInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterL2tpServerInfoCompleteArgs(ctx, l2tpServerInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterL2tpServerInfoCompleteFlags(ctx, l2tpServerInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterL2tpServerInfoCompleteArgs(ctx, l2tpServerInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					l2tpServerInfoParam.ParamTemplate = c.String("param-template")
					l2tpServerInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(l2tpServerInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewL2tpServerInfoVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(l2tpServerInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						l2tpServerInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						l2tpServerInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						l2tpServerInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						l2tpServerInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						l2tpServerInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						l2tpServerInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						l2tpServerInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						l2tpServerInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						l2tpServerInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						l2tpServerInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						l2tpServerInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = l2tpServerInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if l2tpServerInfoParam.GenerateSkeleton {
						l2tpServerInfoParam.GenerateSkeleton = false
						l2tpServerInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(l2tpServerInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := l2tpServerInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), l2tpServerInfoParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(l2tpServerInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, l2tpServerInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", l2tpServerInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(l2tpServerInfoParam.Selector) == 0 || hasTags(&v, l2tpServerInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						l2tpServerInfoParam.SetId(id)
						p := *l2tpServerInfoParam // copy struct value
						l2tpServerInfoParam := &p
						go func() {
							err := funcs.VPCRouterL2tpServerInfo(ctx, l2tpServerInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "l2tp-server-update",
				Usage:     "Update L2TP/IPSec server setting",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:  "disabled",
						Usage: "enable/disable PPTP server",
					},
					&cli.StringFlag{
						Name:  "range-start",
						Usage: "set IPAddress Range(start)",
					},
					&cli.StringFlag{
						Name:    "range-stop",
						Aliases: []string{"range-end"},
						Usage:   "set IPAddress Range(stop)",
					},
					&cli.StringFlag{
						Name:  "pre-shared-secret",
						Usage: "set PreSharedSecret",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = l2tpServerUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, l2tpServerUpdateParam)

					// Set option values
					if c.IsSet("disabled") {
						l2tpServerUpdateParam.Disabled = c.Bool("disabled")
					}
					if c.IsSet("range-start") {
						l2tpServerUpdateParam.RangeStart = c.String("range-start")
					}
					if c.IsSet("range-stop") {
						l2tpServerUpdateParam.RangeStop = c.String("range-stop")
					}
					if c.IsSet("pre-shared-secret") {
						l2tpServerUpdateParam.PreSharedSecret = c.String("pre-shared-secret")
					}
					if c.IsSet("selector") {
						l2tpServerUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						l2tpServerUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						l2tpServerUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						l2tpServerUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						l2tpServerUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						l2tpServerUpdateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterL2tpServerUpdateCompleteArgs(ctx, l2tpServerUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterL2tpServerUpdateCompleteArgs(ctx, l2tpServerUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterL2tpServerUpdateCompleteFlags(ctx, l2tpServerUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterL2tpServerUpdateCompleteArgs(ctx, l2tpServerUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					l2tpServerUpdateParam.ParamTemplate = c.String("param-template")
					l2tpServerUpdateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(l2tpServerUpdateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewL2tpServerUpdateVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(l2tpServerUpdateParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("disabled") {
						l2tpServerUpdateParam.Disabled = c.Bool("disabled")
					}
					if c.IsSet("range-start") {
						l2tpServerUpdateParam.RangeStart = c.String("range-start")
					}
					if c.IsSet("range-stop") {
						l2tpServerUpdateParam.RangeStop = c.String("range-stop")
					}
					if c.IsSet("pre-shared-secret") {
						l2tpServerUpdateParam.PreSharedSecret = c.String("pre-shared-secret")
					}
					if c.IsSet("selector") {
						l2tpServerUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						l2tpServerUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						l2tpServerUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						l2tpServerUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						l2tpServerUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						l2tpServerUpdateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = l2tpServerUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if l2tpServerUpdateParam.GenerateSkeleton {
						l2tpServerUpdateParam.GenerateSkeleton = false
						l2tpServerUpdateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(l2tpServerUpdateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := l2tpServerUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), l2tpServerUpdateParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(l2tpServerUpdateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, l2tpServerUpdateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", l2tpServerUpdateParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(l2tpServerUpdateParam.Selector) == 0 || hasTags(&v, l2tpServerUpdateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !l2tpServerUpdateParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("l2tp-server-update", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						l2tpServerUpdateParam.SetId(id)
						p := *l2tpServerUpdateParam // copy struct value
						l2tpServerUpdateParam := &p
						go func() {
							err := funcs.VPCRouterL2tpServerUpdate(ctx, l2tpServerUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "user-info",
				Aliases:   []string{"user-list"},
				Usage:     "Show information of remote-access users",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = userInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, userInfoParam)

					// Set option values
					if c.IsSet("selector") {
						userInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						userInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						userInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						userInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						userInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						userInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						userInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						userInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						userInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						userInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						userInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterUserInfoCompleteArgs(ctx, userInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterUserInfoCompleteArgs(ctx, userInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterUserInfoCompleteFlags(ctx, userInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterUserInfoCompleteArgs(ctx, userInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					userInfoParam.ParamTemplate = c.String("param-template")
					userInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(userInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewUserInfoVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(userInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						userInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						userInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						userInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						userInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						userInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						userInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						userInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						userInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						userInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						userInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						userInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = userInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if userInfoParam.GenerateSkeleton {
						userInfoParam.GenerateSkeleton = false
						userInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(userInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := userInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), userInfoParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(userInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, userInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", userInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(userInfoParam.Selector) == 0 || hasTags(&v, userInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						userInfoParam.SetId(id)
						p := *userInfoParam // copy struct value
						userInfoParam := &p
						go func() {
							err := funcs.VPCRouterUserInfo(ctx, userInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "user-add",
				Usage:     "Add remote-access user",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "username",
						Aliases: []string{"user"},
						Usage:   "[Required] set remote-access username",
					},
					&cli.StringFlag{
						Name:    "password",
						Aliases: []string{"pass"},
						Usage:   "[Required] set remote-access password",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = userAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, userAddParam)

					// Set option values
					if c.IsSet("username") {
						userAddParam.Username = c.String("username")
					}
					if c.IsSet("password") {
						userAddParam.Password = c.String("password")
					}
					if c.IsSet("selector") {
						userAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						userAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						userAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						userAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						userAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						userAddParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterUserAddCompleteArgs(ctx, userAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterUserAddCompleteArgs(ctx, userAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterUserAddCompleteFlags(ctx, userAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterUserAddCompleteArgs(ctx, userAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					userAddParam.ParamTemplate = c.String("param-template")
					userAddParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(userAddParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewUserAddVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(userAddParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("username") {
						userAddParam.Username = c.String("username")
					}
					if c.IsSet("password") {
						userAddParam.Password = c.String("password")
					}
					if c.IsSet("selector") {
						userAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						userAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						userAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						userAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						userAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						userAddParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = userAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if userAddParam.GenerateSkeleton {
						userAddParam.GenerateSkeleton = false
						userAddParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(userAddParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := userAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), userAddParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(userAddParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, userAddParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", userAddParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(userAddParam.Selector) == 0 || hasTags(&v, userAddParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !userAddParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("user-add", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						userAddParam.SetId(id)
						p := *userAddParam // copy struct value
						userAddParam := &p
						go func() {
							err := funcs.VPCRouterUserAdd(ctx, userAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "user-update",
				Usage:     "Update remote-access user",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target remote-access user",
					},
					&cli.StringFlag{
						Name:    "username",
						Aliases: []string{"user"},
						Usage:   "set remote-access username",
					},
					&cli.StringFlag{
						Name:    "password",
						Aliases: []string{"pass"},
						Usage:   "set remote-access password",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = userUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, userUpdateParam)

					// Set option values
					if c.IsSet("index") {
						userUpdateParam.Index = c.Int("index")
					}
					if c.IsSet("username") {
						userUpdateParam.Username = c.String("username")
					}
					if c.IsSet("password") {
						userUpdateParam.Password = c.String("password")
					}
					if c.IsSet("selector") {
						userUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						userUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						userUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						userUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						userUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						userUpdateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterUserUpdateCompleteArgs(ctx, userUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterUserUpdateCompleteArgs(ctx, userUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterUserUpdateCompleteFlags(ctx, userUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterUserUpdateCompleteArgs(ctx, userUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					userUpdateParam.ParamTemplate = c.String("param-template")
					userUpdateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(userUpdateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewUserUpdateVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(userUpdateParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("index") {
						userUpdateParam.Index = c.Int("index")
					}
					if c.IsSet("username") {
						userUpdateParam.Username = c.String("username")
					}
					if c.IsSet("password") {
						userUpdateParam.Password = c.String("password")
					}
					if c.IsSet("selector") {
						userUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						userUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						userUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						userUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						userUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						userUpdateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = userUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if userUpdateParam.GenerateSkeleton {
						userUpdateParam.GenerateSkeleton = false
						userUpdateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(userUpdateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := userUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), userUpdateParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(userUpdateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, userUpdateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", userUpdateParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(userUpdateParam.Selector) == 0 || hasTags(&v, userUpdateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !userUpdateParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("user-update", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						userUpdateParam.SetId(id)
						p := *userUpdateParam // copy struct value
						userUpdateParam := &p
						go func() {
							err := funcs.VPCRouterUserUpdate(ctx, userUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "user-delete",
				Usage:     "Delete remote-access user",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target remote-access user",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = userDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, userDeleteParam)

					// Set option values
					if c.IsSet("index") {
						userDeleteParam.Index = c.Int("index")
					}
					if c.IsSet("selector") {
						userDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						userDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						userDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						userDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						userDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						userDeleteParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterUserDeleteCompleteArgs(ctx, userDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterUserDeleteCompleteArgs(ctx, userDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterUserDeleteCompleteFlags(ctx, userDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterUserDeleteCompleteArgs(ctx, userDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					userDeleteParam.ParamTemplate = c.String("param-template")
					userDeleteParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(userDeleteParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewUserDeleteVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(userDeleteParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("index") {
						userDeleteParam.Index = c.Int("index")
					}
					if c.IsSet("selector") {
						userDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						userDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						userDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						userDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						userDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						userDeleteParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = userDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if userDeleteParam.GenerateSkeleton {
						userDeleteParam.GenerateSkeleton = false
						userDeleteParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(userDeleteParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := userDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), userDeleteParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(userDeleteParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, userDeleteParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", userDeleteParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(userDeleteParam.Selector) == 0 || hasTags(&v, userDeleteParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !userDeleteParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("user-delete", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						userDeleteParam.SetId(id)
						p := *userDeleteParam // copy struct value
						userDeleteParam := &p
						go func() {
							err := funcs.VPCRouterUserDelete(ctx, userDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "site-to-site-vpn-info",
				Aliases:   []string{"site-to-site-vpn-list"},
				Usage:     "Show information of site-to-site IPSec VPN settings",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = siteToSiteVpnInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, siteToSiteVpnInfoParam)

					// Set option values
					if c.IsSet("selector") {
						siteToSiteVpnInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						siteToSiteVpnInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						siteToSiteVpnInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						siteToSiteVpnInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						siteToSiteVpnInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						siteToSiteVpnInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						siteToSiteVpnInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						siteToSiteVpnInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						siteToSiteVpnInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						siteToSiteVpnInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						siteToSiteVpnInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterSiteToSiteVpnInfoCompleteArgs(ctx, siteToSiteVpnInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterSiteToSiteVpnInfoCompleteArgs(ctx, siteToSiteVpnInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterSiteToSiteVpnInfoCompleteFlags(ctx, siteToSiteVpnInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterSiteToSiteVpnInfoCompleteArgs(ctx, siteToSiteVpnInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					siteToSiteVpnInfoParam.ParamTemplate = c.String("param-template")
					siteToSiteVpnInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(siteToSiteVpnInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewSiteToSiteVpnInfoVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(siteToSiteVpnInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						siteToSiteVpnInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						siteToSiteVpnInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						siteToSiteVpnInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						siteToSiteVpnInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						siteToSiteVpnInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						siteToSiteVpnInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						siteToSiteVpnInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						siteToSiteVpnInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						siteToSiteVpnInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						siteToSiteVpnInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						siteToSiteVpnInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = siteToSiteVpnInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if siteToSiteVpnInfoParam.GenerateSkeleton {
						siteToSiteVpnInfoParam.GenerateSkeleton = false
						siteToSiteVpnInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(siteToSiteVpnInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := siteToSiteVpnInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), siteToSiteVpnInfoParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(siteToSiteVpnInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, siteToSiteVpnInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", siteToSiteVpnInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(siteToSiteVpnInfoParam.Selector) == 0 || hasTags(&v, siteToSiteVpnInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						siteToSiteVpnInfoParam.SetId(id)
						p := *siteToSiteVpnInfoParam // copy struct value
						siteToSiteVpnInfoParam := &p
						go func() {
							err := funcs.VPCRouterSiteToSiteVpnInfo(ctx, siteToSiteVpnInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "site-to-site-vpn-add",
				Usage:     "Add site-to-site IPSec VPN setting",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "peer",
						Usage: "[Required] set peer address",
					},
					&cli.StringFlag{
						Name:  "remote-id",
						Usage: "[Required] set remote-id",
					},
					&cli.StringFlag{
						Name:  "pre-shared-secret",
						Usage: "[Required] set pre-shared-secret",
					},
					&cli.StringSliceFlag{
						Name:  "routes",
						Usage: "[Required] set route list",
					},
					&cli.StringSliceFlag{
						Name:  "local-prefix",
						Usage: "[Required] set local prefix list",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = siteToSiteVpnAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, siteToSiteVpnAddParam)

					// Set option values
					if c.IsSet("peer") {
						siteToSiteVpnAddParam.Peer = c.String("peer")
					}
					if c.IsSet("remote-id") {
						siteToSiteVpnAddParam.RemoteId = c.String("remote-id")
					}
					if c.IsSet("pre-shared-secret") {
						siteToSiteVpnAddParam.PreSharedSecret = c.String("pre-shared-secret")
					}
					if c.IsSet("routes") {
						siteToSiteVpnAddParam.Routes = c.StringSlice("routes")
					}
					if c.IsSet("local-prefix") {
						siteToSiteVpnAddParam.LocalPrefix = c.StringSlice("local-prefix")
					}
					if c.IsSet("selector") {
						siteToSiteVpnAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						siteToSiteVpnAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						siteToSiteVpnAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						siteToSiteVpnAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						siteToSiteVpnAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						siteToSiteVpnAddParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterSiteToSiteVpnAddCompleteArgs(ctx, siteToSiteVpnAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterSiteToSiteVpnAddCompleteArgs(ctx, siteToSiteVpnAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterSiteToSiteVpnAddCompleteFlags(ctx, siteToSiteVpnAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterSiteToSiteVpnAddCompleteArgs(ctx, siteToSiteVpnAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					siteToSiteVpnAddParam.ParamTemplate = c.String("param-template")
					siteToSiteVpnAddParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(siteToSiteVpnAddParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewSiteToSiteVpnAddVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(siteToSiteVpnAddParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("peer") {
						siteToSiteVpnAddParam.Peer = c.String("peer")
					}
					if c.IsSet("remote-id") {
						siteToSiteVpnAddParam.RemoteId = c.String("remote-id")
					}
					if c.IsSet("pre-shared-secret") {
						siteToSiteVpnAddParam.PreSharedSecret = c.String("pre-shared-secret")
					}
					if c.IsSet("routes") {
						siteToSiteVpnAddParam.Routes = c.StringSlice("routes")
					}
					if c.IsSet("local-prefix") {
						siteToSiteVpnAddParam.LocalPrefix = c.StringSlice("local-prefix")
					}
					if c.IsSet("selector") {
						siteToSiteVpnAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						siteToSiteVpnAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						siteToSiteVpnAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						siteToSiteVpnAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						siteToSiteVpnAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						siteToSiteVpnAddParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = siteToSiteVpnAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if siteToSiteVpnAddParam.GenerateSkeleton {
						siteToSiteVpnAddParam.GenerateSkeleton = false
						siteToSiteVpnAddParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(siteToSiteVpnAddParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := siteToSiteVpnAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), siteToSiteVpnAddParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(siteToSiteVpnAddParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, siteToSiteVpnAddParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", siteToSiteVpnAddParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(siteToSiteVpnAddParam.Selector) == 0 || hasTags(&v, siteToSiteVpnAddParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !siteToSiteVpnAddParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("site-to-site-vpn-add", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						siteToSiteVpnAddParam.SetId(id)
						p := *siteToSiteVpnAddParam // copy struct value
						siteToSiteVpnAddParam := &p
						go func() {
							err := funcs.VPCRouterSiteToSiteVpnAdd(ctx, siteToSiteVpnAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "site-to-site-vpn-update",
				Usage:     "Update site-to-site IPSec VPN setting",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target remote-access user",
					},
					&cli.StringFlag{
						Name:  "peer",
						Usage: "set peer address",
					},
					&cli.StringFlag{
						Name:  "remote-id",
						Usage: "set remote-id",
					},
					&cli.StringFlag{
						Name:  "pre-shared-secret",
						Usage: "set pre-shared-secret",
					},
					&cli.StringSliceFlag{
						Name:  "routes",
						Usage: "set route list",
					},
					&cli.StringSliceFlag{
						Name:  "local-prefix",
						Usage: "set local prefix list",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = siteToSiteVpnUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, siteToSiteVpnUpdateParam)

					// Set option values
					if c.IsSet("index") {
						siteToSiteVpnUpdateParam.Index = c.Int("index")
					}
					if c.IsSet("peer") {
						siteToSiteVpnUpdateParam.Peer = c.String("peer")
					}
					if c.IsSet("remote-id") {
						siteToSiteVpnUpdateParam.RemoteId = c.String("remote-id")
					}
					if c.IsSet("pre-shared-secret") {
						siteToSiteVpnUpdateParam.PreSharedSecret = c.String("pre-shared-secret")
					}
					if c.IsSet("routes") {
						siteToSiteVpnUpdateParam.Routes = c.StringSlice("routes")
					}
					if c.IsSet("local-prefix") {
						siteToSiteVpnUpdateParam.LocalPrefix = c.StringSlice("local-prefix")
					}
					if c.IsSet("selector") {
						siteToSiteVpnUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						siteToSiteVpnUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						siteToSiteVpnUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						siteToSiteVpnUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						siteToSiteVpnUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						siteToSiteVpnUpdateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterSiteToSiteVpnUpdateCompleteArgs(ctx, siteToSiteVpnUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterSiteToSiteVpnUpdateCompleteArgs(ctx, siteToSiteVpnUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterSiteToSiteVpnUpdateCompleteFlags(ctx, siteToSiteVpnUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterSiteToSiteVpnUpdateCompleteArgs(ctx, siteToSiteVpnUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					siteToSiteVpnUpdateParam.ParamTemplate = c.String("param-template")
					siteToSiteVpnUpdateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(siteToSiteVpnUpdateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewSiteToSiteVpnUpdateVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(siteToSiteVpnUpdateParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("index") {
						siteToSiteVpnUpdateParam.Index = c.Int("index")
					}
					if c.IsSet("peer") {
						siteToSiteVpnUpdateParam.Peer = c.String("peer")
					}
					if c.IsSet("remote-id") {
						siteToSiteVpnUpdateParam.RemoteId = c.String("remote-id")
					}
					if c.IsSet("pre-shared-secret") {
						siteToSiteVpnUpdateParam.PreSharedSecret = c.String("pre-shared-secret")
					}
					if c.IsSet("routes") {
						siteToSiteVpnUpdateParam.Routes = c.StringSlice("routes")
					}
					if c.IsSet("local-prefix") {
						siteToSiteVpnUpdateParam.LocalPrefix = c.StringSlice("local-prefix")
					}
					if c.IsSet("selector") {
						siteToSiteVpnUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						siteToSiteVpnUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						siteToSiteVpnUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						siteToSiteVpnUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						siteToSiteVpnUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						siteToSiteVpnUpdateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = siteToSiteVpnUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if siteToSiteVpnUpdateParam.GenerateSkeleton {
						siteToSiteVpnUpdateParam.GenerateSkeleton = false
						siteToSiteVpnUpdateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(siteToSiteVpnUpdateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := siteToSiteVpnUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), siteToSiteVpnUpdateParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(siteToSiteVpnUpdateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, siteToSiteVpnUpdateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", siteToSiteVpnUpdateParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(siteToSiteVpnUpdateParam.Selector) == 0 || hasTags(&v, siteToSiteVpnUpdateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !siteToSiteVpnUpdateParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("site-to-site-vpn-update", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						siteToSiteVpnUpdateParam.SetId(id)
						p := *siteToSiteVpnUpdateParam // copy struct value
						siteToSiteVpnUpdateParam := &p
						go func() {
							err := funcs.VPCRouterSiteToSiteVpnUpdate(ctx, siteToSiteVpnUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "site-to-site-vpn-delete",
				Usage:     "Delete site-to-site IPSec VPN setting",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target remote-access user",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = siteToSiteVpnDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, siteToSiteVpnDeleteParam)

					// Set option values
					if c.IsSet("index") {
						siteToSiteVpnDeleteParam.Index = c.Int("index")
					}
					if c.IsSet("selector") {
						siteToSiteVpnDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						siteToSiteVpnDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						siteToSiteVpnDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						siteToSiteVpnDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						siteToSiteVpnDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						siteToSiteVpnDeleteParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterSiteToSiteVpnDeleteCompleteArgs(ctx, siteToSiteVpnDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterSiteToSiteVpnDeleteCompleteArgs(ctx, siteToSiteVpnDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterSiteToSiteVpnDeleteCompleteFlags(ctx, siteToSiteVpnDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterSiteToSiteVpnDeleteCompleteArgs(ctx, siteToSiteVpnDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					siteToSiteVpnDeleteParam.ParamTemplate = c.String("param-template")
					siteToSiteVpnDeleteParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(siteToSiteVpnDeleteParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewSiteToSiteVpnDeleteVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(siteToSiteVpnDeleteParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("index") {
						siteToSiteVpnDeleteParam.Index = c.Int("index")
					}
					if c.IsSet("selector") {
						siteToSiteVpnDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						siteToSiteVpnDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						siteToSiteVpnDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						siteToSiteVpnDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						siteToSiteVpnDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						siteToSiteVpnDeleteParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = siteToSiteVpnDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if siteToSiteVpnDeleteParam.GenerateSkeleton {
						siteToSiteVpnDeleteParam.GenerateSkeleton = false
						siteToSiteVpnDeleteParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(siteToSiteVpnDeleteParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := siteToSiteVpnDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), siteToSiteVpnDeleteParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(siteToSiteVpnDeleteParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, siteToSiteVpnDeleteParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", siteToSiteVpnDeleteParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(siteToSiteVpnDeleteParam.Selector) == 0 || hasTags(&v, siteToSiteVpnDeleteParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !siteToSiteVpnDeleteParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("site-to-site-vpn-delete", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						siteToSiteVpnDeleteParam.SetId(id)
						p := *siteToSiteVpnDeleteParam // copy struct value
						siteToSiteVpnDeleteParam := &p
						go func() {
							err := funcs.VPCRouterSiteToSiteVpnDelete(ctx, siteToSiteVpnDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "site-to-site-vpn-peers",
				Usage:     "Show status of site-to-site IPSec VPN peers",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = siteToSiteVpnPeersParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, siteToSiteVpnPeersParam)

					// Set option values
					if c.IsSet("selector") {
						siteToSiteVpnPeersParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						siteToSiteVpnPeersParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						siteToSiteVpnPeersParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						siteToSiteVpnPeersParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						siteToSiteVpnPeersParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						siteToSiteVpnPeersParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						siteToSiteVpnPeersParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						siteToSiteVpnPeersParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						siteToSiteVpnPeersParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						siteToSiteVpnPeersParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						siteToSiteVpnPeersParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterSiteToSiteVpnPeersCompleteArgs(ctx, siteToSiteVpnPeersParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterSiteToSiteVpnPeersCompleteArgs(ctx, siteToSiteVpnPeersParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterSiteToSiteVpnPeersCompleteFlags(ctx, siteToSiteVpnPeersParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterSiteToSiteVpnPeersCompleteArgs(ctx, siteToSiteVpnPeersParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					siteToSiteVpnPeersParam.ParamTemplate = c.String("param-template")
					siteToSiteVpnPeersParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(siteToSiteVpnPeersParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewSiteToSiteVpnPeersVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(siteToSiteVpnPeersParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						siteToSiteVpnPeersParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						siteToSiteVpnPeersParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						siteToSiteVpnPeersParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						siteToSiteVpnPeersParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						siteToSiteVpnPeersParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						siteToSiteVpnPeersParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						siteToSiteVpnPeersParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						siteToSiteVpnPeersParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						siteToSiteVpnPeersParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						siteToSiteVpnPeersParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						siteToSiteVpnPeersParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = siteToSiteVpnPeersParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if siteToSiteVpnPeersParam.GenerateSkeleton {
						siteToSiteVpnPeersParam.GenerateSkeleton = false
						siteToSiteVpnPeersParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(siteToSiteVpnPeersParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := siteToSiteVpnPeersParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), siteToSiteVpnPeersParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(siteToSiteVpnPeersParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, siteToSiteVpnPeersParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", siteToSiteVpnPeersParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(siteToSiteVpnPeersParam.Selector) == 0 || hasTags(&v, siteToSiteVpnPeersParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						siteToSiteVpnPeersParam.SetId(id)
						p := *siteToSiteVpnPeersParam // copy struct value
						siteToSiteVpnPeersParam := &p
						go func() {
							err := funcs.VPCRouterSiteToSiteVpnPeers(ctx, siteToSiteVpnPeersParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-route-info",
				Aliases:   []string{"static-route-list"},
				Usage:     "Show information of static-routes",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = staticRouteInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, staticRouteInfoParam)

					// Set option values
					if c.IsSet("selector") {
						staticRouteInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						staticRouteInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticRouteInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticRouteInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						staticRouteInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						staticRouteInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						staticRouteInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						staticRouteInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						staticRouteInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						staticRouteInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						staticRouteInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticRouteInfoCompleteArgs(ctx, staticRouteInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticRouteInfoCompleteArgs(ctx, staticRouteInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticRouteInfoCompleteFlags(ctx, staticRouteInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticRouteInfoCompleteArgs(ctx, staticRouteInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					staticRouteInfoParam.ParamTemplate = c.String("param-template")
					staticRouteInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(staticRouteInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewStaticRouteInfoVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(staticRouteInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						staticRouteInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						staticRouteInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticRouteInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticRouteInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						staticRouteInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						staticRouteInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						staticRouteInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						staticRouteInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						staticRouteInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						staticRouteInfoParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						staticRouteInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = staticRouteInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if staticRouteInfoParam.GenerateSkeleton {
						staticRouteInfoParam.GenerateSkeleton = false
						staticRouteInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(staticRouteInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := staticRouteInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticRouteInfoParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(staticRouteInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, staticRouteInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", staticRouteInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(staticRouteInfoParam.Selector) == 0 || hasTags(&v, staticRouteInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticRouteInfoParam.SetId(id)
						p := *staticRouteInfoParam // copy struct value
						staticRouteInfoParam := &p
						go func() {
							err := funcs.VPCRouterStaticRouteInfo(ctx, staticRouteInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-route-add",
				Usage:     "Add static-route",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "prefix",
						Usage: "[Required] set prefix",
					},
					&cli.StringFlag{
						Name:  "next-hop",
						Usage: "[Required] set next-hop",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = staticRouteAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, staticRouteAddParam)

					// Set option values
					if c.IsSet("prefix") {
						staticRouteAddParam.Prefix = c.String("prefix")
					}
					if c.IsSet("next-hop") {
						staticRouteAddParam.NextHop = c.String("next-hop")
					}
					if c.IsSet("selector") {
						staticRouteAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						staticRouteAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						staticRouteAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticRouteAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticRouteAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						staticRouteAddParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticRouteAddCompleteArgs(ctx, staticRouteAddParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticRouteAddCompleteArgs(ctx, staticRouteAddParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticRouteAddCompleteFlags(ctx, staticRouteAddParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticRouteAddCompleteArgs(ctx, staticRouteAddParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					staticRouteAddParam.ParamTemplate = c.String("param-template")
					staticRouteAddParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(staticRouteAddParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewStaticRouteAddVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(staticRouteAddParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("prefix") {
						staticRouteAddParam.Prefix = c.String("prefix")
					}
					if c.IsSet("next-hop") {
						staticRouteAddParam.NextHop = c.String("next-hop")
					}
					if c.IsSet("selector") {
						staticRouteAddParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						staticRouteAddParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						staticRouteAddParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticRouteAddParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticRouteAddParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						staticRouteAddParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = staticRouteAddParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if staticRouteAddParam.GenerateSkeleton {
						staticRouteAddParam.GenerateSkeleton = false
						staticRouteAddParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(staticRouteAddParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := staticRouteAddParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticRouteAddParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(staticRouteAddParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, staticRouteAddParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", staticRouteAddParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(staticRouteAddParam.Selector) == 0 || hasTags(&v, staticRouteAddParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !staticRouteAddParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("static-route-add", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticRouteAddParam.SetId(id)
						p := *staticRouteAddParam // copy struct value
						staticRouteAddParam := &p
						go func() {
							err := funcs.VPCRouterStaticRouteAdd(ctx, staticRouteAddParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-route-update",
				Usage:     "Update static-route",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target static-route",
					},
					&cli.StringFlag{
						Name:  "prefix",
						Usage: "set prefix",
					},
					&cli.StringFlag{
						Name:  "next-hop",
						Usage: "set next-hop",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = staticRouteUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, staticRouteUpdateParam)

					// Set option values
					if c.IsSet("index") {
						staticRouteUpdateParam.Index = c.Int("index")
					}
					if c.IsSet("prefix") {
						staticRouteUpdateParam.Prefix = c.String("prefix")
					}
					if c.IsSet("next-hop") {
						staticRouteUpdateParam.NextHop = c.String("next-hop")
					}
					if c.IsSet("selector") {
						staticRouteUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						staticRouteUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						staticRouteUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticRouteUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticRouteUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						staticRouteUpdateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticRouteUpdateCompleteArgs(ctx, staticRouteUpdateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticRouteUpdateCompleteArgs(ctx, staticRouteUpdateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticRouteUpdateCompleteFlags(ctx, staticRouteUpdateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticRouteUpdateCompleteArgs(ctx, staticRouteUpdateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					staticRouteUpdateParam.ParamTemplate = c.String("param-template")
					staticRouteUpdateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(staticRouteUpdateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewStaticRouteUpdateVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(staticRouteUpdateParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("index") {
						staticRouteUpdateParam.Index = c.Int("index")
					}
					if c.IsSet("prefix") {
						staticRouteUpdateParam.Prefix = c.String("prefix")
					}
					if c.IsSet("next-hop") {
						staticRouteUpdateParam.NextHop = c.String("next-hop")
					}
					if c.IsSet("selector") {
						staticRouteUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						staticRouteUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						staticRouteUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticRouteUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticRouteUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						staticRouteUpdateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = staticRouteUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if staticRouteUpdateParam.GenerateSkeleton {
						staticRouteUpdateParam.GenerateSkeleton = false
						staticRouteUpdateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(staticRouteUpdateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := staticRouteUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticRouteUpdateParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(staticRouteUpdateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, staticRouteUpdateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", staticRouteUpdateParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(staticRouteUpdateParam.Selector) == 0 || hasTags(&v, staticRouteUpdateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !staticRouteUpdateParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("static-route-update", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticRouteUpdateParam.SetId(id)
						p := *staticRouteUpdateParam // copy struct value
						staticRouteUpdateParam := &p
						go func() {
							err := funcs.VPCRouterStaticRouteUpdate(ctx, staticRouteUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "static-route-delete",
				Usage:     "Delete static-route",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "index",
						Usage: "[Required] index of target static-route",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = staticRouteDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, staticRouteDeleteParam)

					// Set option values
					if c.IsSet("index") {
						staticRouteDeleteParam.Index = c.Int("index")
					}
					if c.IsSet("selector") {
						staticRouteDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						staticRouteDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						staticRouteDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticRouteDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticRouteDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						staticRouteDeleteParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterStaticRouteDeleteCompleteArgs(ctx, staticRouteDeleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterStaticRouteDeleteCompleteArgs(ctx, staticRouteDeleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterStaticRouteDeleteCompleteFlags(ctx, staticRouteDeleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterStaticRouteDeleteCompleteArgs(ctx, staticRouteDeleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					staticRouteDeleteParam.ParamTemplate = c.String("param-template")
					staticRouteDeleteParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(staticRouteDeleteParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewStaticRouteDeleteVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(staticRouteDeleteParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("index") {
						staticRouteDeleteParam.Index = c.Int("index")
					}
					if c.IsSet("selector") {
						staticRouteDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						staticRouteDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						staticRouteDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						staticRouteDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						staticRouteDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						staticRouteDeleteParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = staticRouteDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if staticRouteDeleteParam.GenerateSkeleton {
						staticRouteDeleteParam.GenerateSkeleton = false
						staticRouteDeleteParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(staticRouteDeleteParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := staticRouteDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), staticRouteDeleteParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(staticRouteDeleteParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, staticRouteDeleteParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", staticRouteDeleteParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(staticRouteDeleteParam.Selector) == 0 || hasTags(&v, staticRouteDeleteParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !staticRouteDeleteParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("static-route-delete", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						staticRouteDeleteParam.SetId(id)
						p := *staticRouteDeleteParam // copy struct value
						staticRouteDeleteParam := &p
						go func() {
							err := funcs.VPCRouterStaticRouteDelete(ctx, staticRouteDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor",
				Usage:     "Monitor VPCRouter",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "interface",
						Usage: "[Required] index of target interface",
						Value: "0",
					},
					&cli.StringFlag{
						Name:  "start",
						Usage: "set start-time",
					},
					&cli.StringFlag{
						Name:  "end",
						Usage: "set end-time",
					},
					&cli.StringFlag{
						Name:  "key-format",
						Usage: "[Required] set monitoring value key-format",
						Value: "sakuracloud.vpcrouter.{{.ID}}.nic.{{.Index}}",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = monitorParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, monitorParam)

					// Set option values
					if c.IsSet("interface") {
						monitorParam.Interface = c.String("interface")
					}
					if c.IsSet("start") {
						monitorParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						monitorParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						monitorParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterMonitorCompleteArgs(ctx, monitorParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterMonitorCompleteArgs(ctx, monitorParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterMonitorCompleteFlags(ctx, monitorParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterMonitorCompleteArgs(ctx, monitorParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					monitorParam.ParamTemplate = c.String("param-template")
					monitorParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(monitorParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMonitorVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(monitorParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("interface") {
						monitorParam.Interface = c.String("interface")
					}
					if c.IsSet("start") {
						monitorParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						monitorParam.Query = c.String("query")
					}
					if c.IsSet("id") {
						monitorParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = monitorParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if monitorParam.GenerateSkeleton {
						monitorParam.GenerateSkeleton = false
						monitorParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(monitorParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := monitorParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(monitorParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, monitorParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", monitorParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(monitorParam.Selector) == 0 || hasTags(&v, monitorParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorParam.SetId(id)
						p := *monitorParam // copy struct value
						monitorParam := &p
						go func() {
							err := funcs.VPCRouterMonitor(ctx, monitorParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "logs",
				Usage:     "Logs VPCRouter",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "log-name",
						Aliases: []string{"name"},
						Usage:   "set target logfile name",
						Value:   "all",
					},
					&cli.BoolFlag{
						Name:    "follow",
						Aliases: []string{"f"},
						Usage:   "follow log output",
					},
					&cli.Int64Flag{
						Name:  "refresh-interval",
						Usage: "log refresh interval second",
						Value: 3,
					},
					&cli.BoolFlag{
						Name:  "list-log-names",
						Usage: "show log-name list",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					if err := checkConfigVersion(); err != nil {
						return
					}
					if err := applyConfigFromFile(c); err != nil {
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// set default output-type
					// when params have output-type option and have empty value
					var outputTypeHolder interface{} = logsParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// build command context
					ctx := command.NewContext(c, realArgs, logsParam)

					// Set option values
					if c.IsSet("log-name") {
						logsParam.LogName = c.String("log-name")
					}
					if c.IsSet("follow") {
						logsParam.Follow = c.Bool("follow")
					}
					if c.IsSet("refresh-interval") {
						logsParam.RefreshInterval = c.Int64("refresh-interval")
					}
					if c.IsSet("list-log-names") {
						logsParam.ListLogNames = c.Bool("list-log-names")
					}
					if c.IsSet("selector") {
						logsParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						logsParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						logsParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						logsParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						logsParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.VPCRouterLogsCompleteArgs(ctx, logsParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.VPCRouterLogsCompleteArgs(ctx, logsParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.VPCRouterLogsCompleteFlags(ctx, logsParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.VPCRouterLogsCompleteArgs(ctx, logsParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					logsParam.ParamTemplate = c.String("param-template")
					logsParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(logsParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewLogsVPCRouterParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(logsParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("log-name") {
						logsParam.LogName = c.String("log-name")
					}
					if c.IsSet("follow") {
						logsParam.Follow = c.Bool("follow")
					}
					if c.IsSet("refresh-interval") {
						logsParam.RefreshInterval = c.Int64("refresh-interval")
					}
					if c.IsSet("list-log-names") {
						logsParam.ListLogNames = c.Bool("list-log-names")
					}
					if c.IsSet("selector") {
						logsParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						logsParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						logsParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						logsParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						logsParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = logsParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Generate skeleton
					if logsParam.GenerateSkeleton {
						logsParam.GenerateSkeleton = false
						logsParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(logsParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := logsParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), logsParam)

					apiClient := ctx.GetAPIClient().VPCRouter
					ids := []int64{}

					if c.NArg() == 0 {

						if len(logsParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.VPCRouters {
							if hasTags(&v, logsParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", logsParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.VPCRouters {
										if len(logsParam.Selector) == 0 || hasTags(&v, logsParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						logsParam.SetId(id)
						p := *logsParam // copy struct value
						logsParam := &p
						go func() {
							err := funcs.VPCRouterLogs(ctx, logsParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
		},
	}

	// build Category-Resource mapping
	AppendResourceCategoryMap("vpc-router", &schema.Category{
		Key:         "appliance",
		DisplayName: "Appliance",
		Order:       40,
	})

	// build Category-Command mapping

	AppendCommandCategoryMap("vpc-router", "boot", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("vpc-router", "create", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("vpc-router", "delete", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-server-add", &schema.Category{
		Key:         "dhcp-server",
		DisplayName: "DHCP Server Management",
		Order:       60,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-server-delete", &schema.Category{
		Key:         "dhcp-server",
		DisplayName: "DHCP Server Management",
		Order:       60,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-server-info", &schema.Category{
		Key:         "dhcp-server",
		DisplayName: "DHCP Server Management",
		Order:       60,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-server-update", &schema.Category{
		Key:         "dhcp-server",
		DisplayName: "DHCP Server Management",
		Order:       60,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-static-mapping-add", &schema.Category{
		Key:         "dhcp-static-mapping",
		DisplayName: "DHCP Static Map Setting Management",
		Order:       65,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-static-mapping-delete", &schema.Category{
		Key:         "dhcp-static-mapping",
		DisplayName: "DHCP Static Map Setting Management",
		Order:       65,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-static-mapping-info", &schema.Category{
		Key:         "dhcp-static-mapping",
		DisplayName: "DHCP Static Map Setting Management",
		Order:       65,
	})
	AppendCommandCategoryMap("vpc-router", "dhcp-static-mapping-update", &schema.Category{
		Key:         "dhcp-static-mapping",
		DisplayName: "DHCP Static Map Setting Management",
		Order:       65,
	})
	AppendCommandCategoryMap("vpc-router", "disable-internet-connection", &schema.Category{
		Key:         "nic",
		DisplayName: "Network Interface Management",
		Order:       30,
	})
	AppendCommandCategoryMap("vpc-router", "enable-internet-connection", &schema.Category{
		Key:         "nic",
		DisplayName: "Network Interface Management",
		Order:       30,
	})
	AppendCommandCategoryMap("vpc-router", "firewall-add", &schema.Category{
		Key:         "fw",
		DisplayName: "Firewall Setting Management",
		Order:       50,
	})
	AppendCommandCategoryMap("vpc-router", "firewall-delete", &schema.Category{
		Key:         "fw",
		DisplayName: "Firewall Setting Management",
		Order:       50,
	})
	AppendCommandCategoryMap("vpc-router", "firewall-info", &schema.Category{
		Key:         "fw",
		DisplayName: "Firewall Setting Management",
		Order:       50,
	})
	AppendCommandCategoryMap("vpc-router", "firewall-update", &schema.Category{
		Key:         "fw",
		DisplayName: "Firewall Setting Management",
		Order:       50,
	})
	AppendCommandCategoryMap("vpc-router", "interface-connect", &schema.Category{
		Key:         "nic",
		DisplayName: "Network Interface Management",
		Order:       30,
	})
	AppendCommandCategoryMap("vpc-router", "interface-disconnect", &schema.Category{
		Key:         "nic",
		DisplayName: "Network Interface Management",
		Order:       30,
	})
	AppendCommandCategoryMap("vpc-router", "interface-info", &schema.Category{
		Key:         "nic",
		DisplayName: "Network Interface Management",
		Order:       30,
	})
	AppendCommandCategoryMap("vpc-router", "interface-update", &schema.Category{
		Key:         "nic",
		DisplayName: "Network Interface Management",
		Order:       30,
	})
	AppendCommandCategoryMap("vpc-router", "l2tp-server-info", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "l2tp-server-update", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "list", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("vpc-router", "logs", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       500,
	})
	AppendCommandCategoryMap("vpc-router", "monitor", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       500,
	})
	AppendCommandCategoryMap("vpc-router", "port-forwarding-add", &schema.Category{
		Key:         "rnat",
		DisplayName: "Port Forward Setting Management",
		Order:       45,
	})
	AppendCommandCategoryMap("vpc-router", "port-forwarding-delete", &schema.Category{
		Key:         "rnat",
		DisplayName: "Port Forward Setting Management",
		Order:       45,
	})
	AppendCommandCategoryMap("vpc-router", "port-forwarding-info", &schema.Category{
		Key:         "rnat",
		DisplayName: "Port Forward Setting Management",
		Order:       45,
	})
	AppendCommandCategoryMap("vpc-router", "port-forwarding-update", &schema.Category{
		Key:         "rnat",
		DisplayName: "Port Forward Setting Management",
		Order:       45,
	})
	AppendCommandCategoryMap("vpc-router", "pptp-server-info", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "pptp-server-update", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "read", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("vpc-router", "reset", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("vpc-router", "shutdown", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("vpc-router", "shutdown-force", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("vpc-router", "site-to-site-vpn-add", &schema.Category{
		Key:         "s2s",
		DisplayName: "Site to Site IPSec VPN Management",
		Order:       80,
	})
	AppendCommandCategoryMap("vpc-router", "site-to-site-vpn-delete", &schema.Category{
		Key:         "s2s",
		DisplayName: "Site to Site IPSec VPN Management",
		Order:       80,
	})
	AppendCommandCategoryMap("vpc-router", "site-to-site-vpn-info", &schema.Category{
		Key:         "s2s",
		DisplayName: "Site to Site IPSec VPN Management",
		Order:       80,
	})
	AppendCommandCategoryMap("vpc-router", "site-to-site-vpn-peers", &schema.Category{
		Key:         "s2s",
		DisplayName: "Site to Site IPSec VPN Management",
		Order:       80,
	})
	AppendCommandCategoryMap("vpc-router", "site-to-site-vpn-update", &schema.Category{
		Key:         "s2s",
		DisplayName: "Site to Site IPSec VPN Management",
		Order:       80,
	})
	AppendCommandCategoryMap("vpc-router", "static-nat-add", &schema.Category{
		Key:         "snat",
		DisplayName: "Static NAT Setting Management",
		Order:       40,
	})
	AppendCommandCategoryMap("vpc-router", "static-nat-delete", &schema.Category{
		Key:         "snat",
		DisplayName: "Static NAT Setting Management",
		Order:       40,
	})
	AppendCommandCategoryMap("vpc-router", "static-nat-info", &schema.Category{
		Key:         "snat",
		DisplayName: "Static NAT Setting Management",
		Order:       40,
	})
	AppendCommandCategoryMap("vpc-router", "static-nat-update", &schema.Category{
		Key:         "snat",
		DisplayName: "Static NAT Setting Management",
		Order:       40,
	})
	AppendCommandCategoryMap("vpc-router", "static-route-add", &schema.Category{
		Key:         "routing",
		DisplayName: "Static Route Management",
		Order:       90,
	})
	AppendCommandCategoryMap("vpc-router", "static-route-delete", &schema.Category{
		Key:         "routing",
		DisplayName: "Static Route Management",
		Order:       90,
	})
	AppendCommandCategoryMap("vpc-router", "static-route-info", &schema.Category{
		Key:         "routing",
		DisplayName: "Static Route Management",
		Order:       90,
	})
	AppendCommandCategoryMap("vpc-router", "static-route-update", &schema.Category{
		Key:         "routing",
		DisplayName: "Static Route Management",
		Order:       90,
	})
	AppendCommandCategoryMap("vpc-router", "update", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("vpc-router", "user-add", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "user-delete", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "user-info", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "user-update", &schema.Category{
		Key:         "remote-access",
		DisplayName: "RemoteAccess(VPN) Setting Management",
		Order:       70,
	})
	AppendCommandCategoryMap("vpc-router", "wait-for-boot", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("vpc-router", "wait-for-down", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})

	// build Category-Param mapping

	AppendFlagCategoryMap("vpc-router", "boot", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "boot", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "boot", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "boot", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "boot", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "boot", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "create", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "create", "boot-after-create", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       30,
	})
	AppendFlagCategoryMap("vpc-router", "create", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "create", "description", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "create", "disable-internet-connection", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       20,
	})
	AppendFlagCategoryMap("vpc-router", "create", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "create", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "create", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "create", "icon-id", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "create", "ipaddress1", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       20,
	})
	AppendFlagCategoryMap("vpc-router", "create", "ipaddress2", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       20,
	})
	AppendFlagCategoryMap("vpc-router", "create", "name", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "create", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "create", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "create", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "create", "plan", &schema.Category{
		Key:         "router",
		DisplayName: "VPCRouter options",
		Order:       10,
	})
	AppendFlagCategoryMap("vpc-router", "create", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "create", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "create", "switch-id", &schema.Category{
		Key:         "router",
		DisplayName: "VPCRouter options",
		Order:       10,
	})
	AppendFlagCategoryMap("vpc-router", "create", "tags", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "create", "vip", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       20,
	})
	AppendFlagCategoryMap("vpc-router", "create", "vrid", &schema.Category{
		Key:         "router",
		DisplayName: "VPCRouter options",
		Order:       10,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "force", &schema.Category{
		Key:         "router",
		DisplayName: "VPCRouter options",
		Order:       10,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "delete", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "dns-servers", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "interface", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "range-start", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "range-stop", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-add", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-delete", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-delete", "interface", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-delete", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-delete", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-delete", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "dns-servers", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "interface", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "range-start", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "range-stop", &schema.Category{
		Key:         "DHCP-Server",
		DisplayName: "DHCP-Server options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-server-update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-add", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-add", "ipaddress", &schema.Category{
		Key:         "DHCP-Static-Mapping",
		DisplayName: "DHCP-Static-Mapping options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-add", "macaddress", &schema.Category{
		Key:         "DHCP-Static-Mapping",
		DisplayName: "DHCP-Static-Mapping options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-add", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-add", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-add", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-delete", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-delete", "index", &schema.Category{
		Key:         "DHCP-Static-Mapping",
		DisplayName: "DHCP-Static-Mapping options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-delete", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-delete", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-delete", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-update", "index", &schema.Category{
		Key:         "DHCP-Static-Mapping",
		DisplayName: "DHCP-Static-Mapping options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-update", "ipaddress", &schema.Category{
		Key:         "DHCP-Static-Mapping",
		DisplayName: "DHCP-Static-Mapping options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-update", "macaddress", &schema.Category{
		Key:         "DHCP-Static-Mapping",
		DisplayName: "DHCP-Static-Mapping options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "dhcp-static-mapping-update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "disable-internet-connection", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "disable-internet-connection", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "disable-internet-connection", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "disable-internet-connection", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "disable-internet-connection", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "disable-internet-connection", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "enable-internet-connection", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "enable-internet-connection", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "enable-internet-connection", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "enable-internet-connection", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "enable-internet-connection", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "enable-internet-connection", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "action", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "description", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "destination-network", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "destination-port", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "direction", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "enable-logging", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "interface", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "protocol", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "source-network", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-add", "source-port", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-delete", "direction", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-delete", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-delete", "index", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-delete", "interface", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-delete", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-delete", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-delete", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "direction", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "interface", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "action", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "description", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "destination-network", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "destination-port", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "direction", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "enable-logging", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "index", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "interface", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "protocol", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "source-network", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "firewall-update", "source-port", &schema.Category{
		Key:         "Firewall",
		DisplayName: "Firewall options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "interface", &schema.Category{
		Key:         "interface",
		DisplayName: "Interface options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "ipaddress", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "ipaddress1", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "ipaddress2", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "nw-masklen", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "switch-id", &schema.Category{
		Key:         "interface",
		DisplayName: "Interface options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-connect", "with-reboot", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-disconnect", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-disconnect", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-disconnect", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "interface-disconnect", "interface", &schema.Category{
		Key:         "interface",
		DisplayName: "Interface options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-disconnect", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-disconnect", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-disconnect", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "interface-disconnect", "with-reboot", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "interface-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "alias", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "interface", &schema.Category{
		Key:         "interface",
		DisplayName: "Interface options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "ipaddress", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "ipaddress1", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "ipaddress2", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "nw-masklen", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "switch-id", &schema.Category{
		Key:         "interface",
		DisplayName: "Interface options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "interface-update", "with-reboot", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "disabled", &schema.Category{
		Key:         "L2TP-IPSec",
		DisplayName: "L2TP-IPSec options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "pre-shared-secret", &schema.Category{
		Key:         "L2TP-IPSec",
		DisplayName: "L2TP-IPSec options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "range-start", &schema.Category{
		Key:         "L2TP-IPSec",
		DisplayName: "L2TP-IPSec options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "range-stop", &schema.Category{
		Key:         "L2TP-IPSec",
		DisplayName: "L2TP-IPSec options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "l2tp-server-update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "list", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "list", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "list", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "list", "from", &schema.Category{
		Key:         "limit-offset",
		DisplayName: "Limit/Offset options",
		Order:       2147483597,
	})
	AppendFlagCategoryMap("vpc-router", "list", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "list", "id", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "list", "max", &schema.Category{
		Key:         "limit-offset",
		DisplayName: "Limit/Offset options",
		Order:       2147483597,
	})
	AppendFlagCategoryMap("vpc-router", "list", "name", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "list", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "list", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "list", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "list", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "list", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "list", "sort", &schema.Category{
		Key:         "sort",
		DisplayName: "Sort options",
		Order:       2147483607,
	})
	AppendFlagCategoryMap("vpc-router", "list", "tags", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "logs", "follow", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "logs", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "logs", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "logs", "list-log-names", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "logs", "log-name", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "logs", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "logs", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "logs", "refresh-interval", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "logs", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "interface", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "monitor", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "description", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "global-port", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "private-ipaddress", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "private-port", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "protocol", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-add", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-delete", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-delete", "index", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-delete", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-delete", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-delete", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "description", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "global-port", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "index", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "private-ipaddress", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "private-port", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "protocol", &schema.Category{
		Key:         "Port-Forwarding",
		DisplayName: "Port-Forwarding options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "port-forwarding-update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-update", "disabled", &schema.Category{
		Key:         "PPTP",
		DisplayName: "PPTP options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-update", "range-start", &schema.Category{
		Key:         "PPTP",
		DisplayName: "PPTP options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-update", "range-stop", &schema.Category{
		Key:         "PPTP",
		DisplayName: "PPTP options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "pptp-server-update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "read", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "read", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "read", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "read", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "read", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "read", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "read", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "read", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "read", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "read", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "read", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "reset", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "reset", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "reset", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "reset", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "reset", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "reset", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown-force", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown-force", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown-force", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown-force", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown-force", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "shutdown-force", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "local-prefix", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "peer", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "pre-shared-secret", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "remote-id", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "routes", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-add", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-delete", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-delete", "index", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-delete", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-delete", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-delete", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-peers", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-peers", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-peers", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-peers", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-peers", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-peers", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-peers", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-peers", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-peers", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-peers", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-peers", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "index", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "local-prefix", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "peer", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "pre-shared-secret", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "remote-id", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "routes", &schema.Category{
		Key:         "Site-To-Site IPSec VPN",
		DisplayName: "Site-To-Site IPSec VPN options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "site-to-site-vpn-update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-add", "description", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-add", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-add", "global", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-add", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-add", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-add", "private", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-add", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-delete", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-delete", "index", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-delete", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-delete", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-delete", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "description", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "global", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "index", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "private", &schema.Category{
		Key:         "Static-NAT",
		DisplayName: "Static-NAT options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-nat-update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-add", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-add", "next-hop", &schema.Category{
		Key:         "Static-Route",
		DisplayName: "Static-Route options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-add", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-add", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-add", "prefix", &schema.Category{
		Key:         "Static-Route",
		DisplayName: "Static-Route options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-add", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-delete", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-delete", "index", &schema.Category{
		Key:         "Static-Route",
		DisplayName: "Static-Route options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-delete", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-delete", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-delete", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-update", "index", &schema.Category{
		Key:         "Static-Route",
		DisplayName: "Static-Route options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-update", "next-hop", &schema.Category{
		Key:         "Static-Route",
		DisplayName: "Static-Route options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-update", "prefix", &schema.Category{
		Key:         "Static-Route",
		DisplayName: "Static-Route options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "static-route-update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "update", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "update", "description", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "update", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "update", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "update", "icon-id", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "update", "internet-connection", &schema.Category{
		Key:         "router",
		DisplayName: "VPCRouter options",
		Order:       10,
	})
	AppendFlagCategoryMap("vpc-router", "update", "name", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "update", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "update", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "update", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "update", "syslog-host", &schema.Category{
		Key:         "router",
		DisplayName: "VPCRouter options",
		Order:       10,
	})
	AppendFlagCategoryMap("vpc-router", "update", "tags", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("vpc-router", "user-add", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-add", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-add", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "user-add", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-add", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-add", "password", &schema.Category{
		Key:         "user",
		DisplayName: "User options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "user-add", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "user-add", "username", &schema.Category{
		Key:         "user",
		DisplayName: "User options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "user-delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-delete", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "user-delete", "index", &schema.Category{
		Key:         "user",
		DisplayName: "User options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "user-delete", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-delete", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-delete", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("vpc-router", "user-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "user-update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "user-update", "index", &schema.Category{
		Key:         "user",
		DisplayName: "User options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "user-update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "user-update", "password", &schema.Category{
		Key:         "user",
		DisplayName: "User options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "user-update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "user-update", "username", &schema.Category{
		Key:         "user",
		DisplayName: "User options",
		Order:       1,
	})
	AppendFlagCategoryMap("vpc-router", "wait-for-boot", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "wait-for-boot", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "wait-for-boot", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "wait-for-boot", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "wait-for-boot", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("vpc-router", "wait-for-down", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "wait-for-down", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("vpc-router", "wait-for-down", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "wait-for-down", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("vpc-router", "wait-for-down", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})

	// append command to GlobalContext
	Commands = append(Commands, cliCommand)
}
